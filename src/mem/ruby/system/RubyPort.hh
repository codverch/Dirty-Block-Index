#ifndef RUBYPORT_H
#define RUBYPORT_H

#include "mem/ruby/libruby.hh"
#include <string>
#include <assert.h>

using namespace std;

class RubyPort {
public:
  RubyPort(const string & name)
    : m_name(name)
  {
    m_port_id = m_num_ports++;
    m_request_cnt = 0;
    m_hit_callback = NULL;
    assert(m_num_ports <= 2048); // see below for reason
  }
  virtual ~RubyPort() {}

  virtual int64_t makeRequest(const RubyRequest & request) = 0;

  void registerHitCallback(void (*hit_callback)(int64_t request_id)) {
    assert(m_hit_callback == NULL); // can't assign hit_callback twice
    m_hit_callback = hit_callback;
  }

protected:
  const string m_name;
  void (*m_hit_callback)(int64_t);

  int64_t makeUniqueRequestID() {
    // The request ID is generated by combining the port ID with a request count
    // so that request IDs can be formed concurrently by multiple threads.
    // IDs are formed as follows:
    //
    //
    //   0        PortID                         Request Count
    // +----+---------------+-----------------------------------------------------+
    // | 63 |     62-48     |                         47-0                        |
    // +----+---------------+-----------------------------------------------------+
    //
    //
    //  This limits the system to a maximum of 2^11 == 2048 components
    //  and 2^48 ~= 3x10^14 requests per component

    int64_t id = (static_cast<uint64_t>(m_port_id) << 48) | m_request_cnt;
    m_request_cnt++;
    // assert((m_request_cnt & (1<<48)) == 0);
    return id;
  }

private:
  static uint16_t m_num_ports;
  uint16_t m_port_id;
  uint64_t m_request_cnt;
};

#endif
