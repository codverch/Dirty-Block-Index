// -*- mode:c++ -*-

// Copyright (c) 2010 ARM Limited
// All rights reserved
//
// The license below extends only to copyright in the software and shall
// not be construed as granting a license to any other intellectual
// property including but not limited to intellectual property relating
// to a hardware implementation of the functionality of the software
// licensed hereunder.  You may use the software subject to the license
// terms below provided that you ensure that this notice is replicated
// unmodified and in its entirety in all distributions of the software,
// modified or unmodified, in source code or in binary form.
//
// Copyright (c) 2007-2008 The Florida State University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer;
// redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution;
// neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Authors: Stephen Hines

////////////////////////////////////////////////////////////////////
//
// Memory-format instructions
//

def template LoadStoreDeclare {{
    /**
     * Static instruction class for "%(mnemonic)s".
     */
    class %(class_name)s : public %(base_class)s
    {
      public:

        /// Constructor.
        %(class_name)s(ExtMachInst machInst);

        %(BasicExecDeclare)s

        %(InitiateAccDeclare)s

        %(CompleteAccDeclare)s
    };
}};


def template InitiateAccDeclare {{
    Fault initiateAcc(%(CPU_exec_context)s *, Trace::InstRecord *) const;
}};


def template CompleteAccDeclare {{
    Fault completeAcc(PacketPtr,  %(CPU_exec_context)s *, Trace::InstRecord *) const;
}};


def template LoadStoreConstructor {{
    inline %(class_name)s::%(class_name)s(ExtMachInst machInst)
         : %(base_class)s("%(mnemonic)s", machInst, %(op_class)s)
    {
        %(constructor)s;
    }
}};

let {{
    def buildPUBWLCase(p, u, b, w, l):
        return (p << 4) + (u << 3) + (b << 2) + (w << 1) + (l << 0)

    def buildMode3Inst(p, u, i, w, type, code, mnem):
        op = ("-", "+")[u]
        offset = ("%s Rm", "%s hilo")[i] % op
        ea_code = "EA = Rn %s;" % ("", offset)[p]
        if p == 0 or w == 1:
            code += "Rn = Rn %s;" % offset
        newSuffix = "_P%dU%dI%dW%d" % (p, u, i, w)
        suffix = ("Reg", "Hilo")[i]
        return LoadStoreBase(mnem, mnem.capitalize() + newSuffix,
                ea_code, code, mem_flags = [], inst_flags = [],
                base_class = 'Memory' + suffix,
                exec_template_base = type.capitalize())
}};

def format AddrMode2(imm) {{
    if eval(imm):
        imm = True
    else:
        imm = False

    header_output = decoder_output = exec_output = ""
    decode_block = "switch(PUBWL) {\n"

    # Loop over all the values of p, u, b, w and l and build instructions and
    # a decode block for them.
    for p in (0, 1):
        for u in (0, 1):
            for b in (0, 1):
                for w in (0, 1):
                    post = (p == 0)
                    user = (p == 0 and w == 0)
                    writeback = (p == 0 or w == 1)
                    add = (u == 1)
                    if b == 0:
                        size = 4
                    else:
                        size = 1
                    if add:
                        addStr = "true"
                    else:
                        addStr = "false"
                    if imm:
                        newDecode = "return new %s(machInst, RD, RN," + \
                                                  "%s, machInst.immed11_0);"
                        loadClass = loadImmClassName(post, add, writeback,
                                                     size, False, user)
                        storeClass = storeImmClassName(post, add, writeback,
                                                       size, False, user)
                        loadDecode = newDecode % (loadClass, addStr)
                        storeDecode = newDecode % (storeClass, addStr)
                    else:
                        newDecode = "return new %s(machInst, RD, RN, %s," + \
                                                  "machInst.shiftSize," + \
                                                  "machInst.shift, RM);"
                        loadClass = loadRegClassName(post, add, writeback,
                                                     size, False, user)
                        storeClass = storeRegClassName(post, add, writeback,
                                                       size, False, user)
                        loadDecode = newDecode % (loadClass, addStr)
                        storeDecode = newDecode % (storeClass, addStr)
                    decode = '''
                        case %#x:
                          {%s}
                          break;
                    '''
                    decode_block += decode % \
                        (buildPUBWLCase(p,u,b,w,1), loadDecode)
                    decode_block += decode % \
                        (buildPUBWLCase(p,u,b,w,0), storeDecode)
    decode_block += '''
        default:
          return new Unknown(machInst);
        break;
    }'''
}};

def format AddrMode3(l0Type, l0Code, l1Type, l1Code) {{
    l0Code = ArmGenericCodeSubs(l0Code);
    l1Code = ArmGenericCodeSubs(l1Code);

    header_output = decoder_output = exec_output = ""
    decode_block = "switch(PUBWL) {\n"
    (l0Mnem, l1Mnem) = name.split("_");

    # Loop over all the values of p, u, i, w and l and build instructions and
    # a decode block for them.
    for (l, type, code, mnem) in ((0, l0Type, l0Code, l0Mnem),
                                  (1, l1Type, l1Code, l1Mnem)):
        for p in (0, 1):
            wset = (0, 1)
            if (p == 0):
                wset = (0,)
            for u in (0, 1):
                for i in (0, 1):
                    for w in wset:
                        (new_header_output,
                         new_decoder_output,
                         new_decode_block,
                         new_exec_output) = buildMode3Inst(p, u, i, w,
                                                           type, code, mnem)
                        header_output += new_header_output
                        decoder_output += new_decoder_output
                        exec_output += new_exec_output
                        decode_block += '''
                            case %#x:
                              {%s}
                              break;
                        ''' % (buildPUBWLCase(p,u,i,w,l), new_decode_block)

    decode_block += '''
        default:
          return new Unknown(machInst);
        break;
    }'''
}};

def format Thumb32LoadWord() {{
    decode = '''
    {
        uint32_t op1 = bits(machInst, 24, 23);
        if (bits(op1, 1) == 0) {
            uint32_t op2 = bits(machInst, 11, 6);
            if (HTRN == 0xF) {
                if (UP) {
                    return new %(literal_u)s(machInst, RT, INTREG_PC,
                                             true, IMMED_11_0);
                } else {
                    return new %(literal)s(machInst, RT, INTREG_PC,
                                           false, IMMED_11_0);
                }
            } else if (op1 == 0x1) {
                return new %(imm_pu)s(machInst, RT, RN, true, IMMED_11_0);
            } else if (op2 == 0) {
                return new %(register)s(machInst, RT, RN, UP,
                                        bits(machInst, 5, 4), LSL, RM);
            } else if ((op2 & 0x3c) == 0x38) {
                return new %(ldrt)s(machInst, RT, RN, true, IMMED_7_0);
            } else if ((op2 & 0x3c) == 0x30 || //P
                       (op2 & 0x24) == 0x24) { //W
                uint32_t puw = bits(machInst, 10, 8);
                uint32_t imm = IMMED_7_0;
                switch (puw) {
                  case 0:
                  case 2:
                    // If we're here, either P or W must have been set.
                    panic("Neither P or W set, but that "
                            "shouldn't be possible.\\n");
                  case 1:
                    return new %(imm_w)s(machInst, RT, RN, false, imm);
                  case 3:
                    return new %(imm_uw)s(machInst, RT, RN, true, imm);
                  case 4:
                    return new %(imm_p)s(machInst, RT, RN, false, imm);
                  case 5:
                    return new %(imm_pw)s(machInst, RT, RN, false, imm);
                  case 6:
                    return new %(imm_pu)s(machInst, RT, RN, true, imm);
                  case 7:
                    return new %(imm_puw)s(machInst, RT, RN, true, imm);
                }
            }
        } else {
            return new Unknown(machInst);
        }
    }
    '''
    classNames = {
        "literal_u" : loadImmClassName(False, True, False),
        "literal" : loadImmClassName(False, False, False),
        "register" : loadRegClassName(False, True, False),
        "ldrt" : loadImmClassName(False, True, False, user=True),
        "imm_w" : loadImmClassName(True, False, True),
        "imm_uw" : loadImmClassName(True, True, True),
        "imm_p" : loadImmClassName(False, False, False),
        "imm_pw" : loadImmClassName(False, False, True),
        "imm_pu" : loadImmClassName(False, True, False),
        "imm_puw" : loadImmClassName(False, True, True)
    }
    decode_block = decode % classNames
}};

def format Thumb32StoreSingle() {{
    def buildPuwDecode(size):
        puwDecode = '''
                {
                    uint32_t puw = bits(machInst, 10, 8);
                    uint32_t imm = IMMED_7_0;
                    switch (puw) {
                      case 0:
                      case 2:
                        // If we're here, either P or W must have been set.
                        panic("Neither P or W set, but that "
                                "shouldn't be possible.\\n");
                      case 1:
                        return new %(imm_w)s(machInst, RT, RN, false, imm);
                      case 3:
                        return new %(imm_uw)s(machInst, RT, RN, true, imm);
                      case 4:
                        return new %(imm_p)s(machInst, RT, RN, false, imm);
                      case 5:
                        return new %(imm_pw)s(machInst, RT, RN, false, imm);
                      case 6:
                        return new %(imm_pu)s(machInst, RT, RN, true, imm);
                      case 7:
                        return new %(imm_puw)s(machInst, RT, RN, true, imm);
                    }
                }
        '''
        return puwDecode % {
            "imm_w" : storeImmClassName(True, False, True, size=size),
            "imm_uw" : storeImmClassName(True, True, True, size=size),
            "imm_p" : storeImmClassName(False, False, False, size=size),
            "imm_pw" : storeImmClassName(False, False, True, size=size),
            "imm_pu" : storeImmClassName(False, True, False, size=size),
            "imm_puw" : storeImmClassName(False, True, True, size=size)
        }
    decode = '''
    {
        uint32_t op1 = bits(machInst, 23, 21);
        uint32_t op2 = bits(machInst, 11, 6);
        bool op2Puw = ((op2 & 0x24) == 0x24 ||
                       (op2 & 0x3c) == 0x30);
        if (op1 == 4) {
            return new %(strb_imm)s(machInst, RT, RN, true, IMMED_11_0);
        } else if (op1 == 0 && op2Puw) {
            %(strb_puw)s;
        } else if (op1 == 0 && ((op2 & 0x3c) == 0x38)) {
            return new %(strbt)s(machInst, RT, RN, true, IMMED_7_0);
        } else if (op1 == 0 && op2 == 0) {
            return new %(strb_reg)s(machInst, RT, RN, true,
                                    bits(machInst, 5, 4), LSL, RM);
        } else if (op1 == 5) {
            return new %(strh_imm)s(machInst, RT, RN, true, IMMED_11_0);
        } else if (op1 == 1 && op2Puw) {
            %(strh_puw)s;
        } else if (op1 == 1 && ((op2 & 0x3c) == 0x38)) {
            return new %(strht)s(machInst, RT, RN, true, IMMED_7_0);
        } else if (op1 == 1 && op2 == 0) {
            return new %(strh_reg)s(machInst, RT, RN, true,
                                    bits(machInst, 5, 4), LSL, RM);
        } else if (op1 == 6) {
            return new %(str_imm)s(machInst, RT, RN, true, IMMED_11_0);
        } else if (op1 == 2 && op2Puw) {
            %(str_puw)s;
        } else if (op1 == 2 && ((op2 & 0x3c) == 0x38)) {
            return new %(strt)s(machInst, RT, RN, true, IMMED_7_0);
        } else if (op1 == 2 && op2 == 0) {
            return new %(str_reg)s(machInst, RT, RN, true,
                                   bits(machInst, 5, 4), LSL, RM);
        } else {
            return new Unknown(machInst);
        }
    }
    '''
    classNames = {
        "strb_imm" : storeImmClassName(False, True, False, size=1),
        "strb_puw" : buildPuwDecode(1),
        "strbt" : storeImmClassName(False, True, False, user=True, size=1),
        "strb_reg" : storeRegClassName(False, True, False, size=1),
        "strh_imm" : storeImmClassName(False, True, False, size=2),
        "strh_puw" : buildPuwDecode(2),
        "strht" : storeImmClassName(False, True, False, user=True, size=2),
        "strh_reg" : storeRegClassName(False, True, False, size=2),
        "str_imm" : storeImmClassName(False, True, False),
        "str_puw" : buildPuwDecode(4),
        "strt" : storeImmClassName(False, True, False, user=True),
        "str_reg" : storeRegClassName(False, True, False)
    }
    decode_block = decode % classNames
}};

def format Thumb16MemReg() {{
    decode = '''
    {
        const uint32_t opb = bits(machInst, 11, 9);
        const uint32_t rt = bits(machInst, 2, 0);
        const uint32_t rn = bits(machInst, 5, 3);
        const uint32_t rm = bits(machInst, 8, 6);
        switch (opb) {
          case 0x0:
            return new %(str)s(machInst, rt, rn, true, 0, LSL, rm);
          case 0x1:
            return new %(strh)s(machInst, rt, rn, true, 0, LSL, rm);
          case 0x2:
            return new %(strb)s(machInst, rt, rn, true, 0, LSL, rm);
          case 0x3:
            return new %(ldrsb)s(machInst, rt, rn, true, 0, LSL, rm);
          case 0x4:
            return new %(ldr)s(machInst, rt, rn, true, 0, LSL, rm);
          case 0x5:
            return new %(ldrh)s(machInst, rt, rn, true, 0, LSL, rm);
          case 0x6:
            return new %(ldrb)s(machInst, rt, rn, true, 0, LSL, rm);
          case 0x7:
            return new %(ldrsh)s(machInst, rt, rn, true, 0, LSL, rm);
        }
    }
    '''
    classNames = {
        "str" : storeRegClassName(False, True, False),
        "strh" : storeRegClassName(False, True, False, size=2),
        "strb" : storeRegClassName(False, True, False, size=1),
        "ldrsb" : loadRegClassName(False, True, False, sign=True, size=1),
        "ldr" : loadRegClassName(False, True, False),
        "ldrh" : loadRegClassName(False, True, False, size=2),
        "ldrb" : loadRegClassName(False, True, False, size=1),
        "ldrsh" : loadRegClassName(False, True, False, sign=True, size=2),
    }
    decode_block = decode % classNames
}};

def format ArmLoadMemory(memacc_code, ea_code = {{ EA = Rn + disp; }},
                     mem_flags = [], inst_flags = []) {{
    ea_code = ArmGenericCodeSubs(ea_code)
    memacc_code = ArmGenericCodeSubs(memacc_code)
    (header_output, decoder_output, decode_block, exec_output) = \
        LoadStoreBase(name, Name, ea_code, memacc_code, mem_flags, inst_flags,
                      decode_template = BasicDecode,
                      exec_template_base = 'Load')
}};

def format ArmStoreMemory(memacc_code, ea_code = {{ EA = Rn + disp; }},
                     mem_flags = [], inst_flags = []) {{
    ea_code = ArmGenericCodeSubs(ea_code)
    memacc_code = ArmGenericCodeSubs(memacc_code)
    (header_output, decoder_output, decode_block, exec_output) = \
        LoadStoreBase(name, Name, ea_code, memacc_code, mem_flags, inst_flags,
                      exec_template_base = 'Store')
}};

