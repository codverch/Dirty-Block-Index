// -*- mode:c++ -*-

// Copyright (c) 2010 ARM Limited
// All rights reserved
//
// The license below extends only to copyright in the software and shall
// not be construed as granting a license to any other intellectual
// property including but not limited to intellectual property relating
// to a hardware implementation of the functionality of the software
// licensed hereunder.  You may use the software subject to the license
// terms below provided that you ensure that this notice is replicated
// unmodified and in its entirety in all distributions of the software,
// modified or unmodified, in source code or in binary form.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer;
// redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution;
// neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Authors: Gabe Black

let {{

    header_output = ""
    decoder_output = ""
    exec_output = ""

    def storeImmClassName(post, add, writeback, \
                          size=4, sign=False, user=False):
        return memClassName("STORE_IMM", post, add, writeback,
                            size, sign, user)

    def storeRegClassName(post, add, writeback, \
                          size=4, sign=False, user=False):
        return memClassName("STORE_REG", post, add, writeback,
                            size, sign, user)

    def storeDoubleImmClassName(post, add, writeback):
        return memClassName("STORE_IMMD", post, add, writeback,
                            4, False, False)

    def storeDoubleRegClassName(post, add, writeback):
        return memClassName("STORE_REGD", post, add, writeback,
                            4, False, False)

    def emitStore(name, Name, imm, eaCode, accCode, \
                  memFlags, instFlags, base, double=False):
        global header_output, decoder_output, exec_output

        (newHeader,
         newDecoder,
         newExec) = loadStoreBase(name, Name, imm,
                                  eaCode, accCode,
                                  memFlags, instFlags, double,
                                  base, execTemplateBase = 'Store')

        header_output += newHeader
        decoder_output += newDecoder
        exec_output += newExec

    def buildImmStore(mnem, post, add, writeback, \
                      size=4, sign=False, user=False):
        name = mnem
        Name = storeImmClassName(post, add, writeback, \
                                 size, sign, user)

        if add:
            op = " +"
        else:
            op = " -"

        offset = op + " imm"
        eaCode = "EA = Base"
        if not post:
            eaCode += offset
        eaCode += ";"

        accCode = "Mem%s = Dest;\n" % buildMemSuffix(sign, size)
        if writeback:
            accCode += "Base = Base %s;\n" % offset
        base = buildMemBase("MemoryImm", post, writeback)

        emitStore(name, Name, True, eaCode, accCode, [], [], base)

    def buildRegStore(mnem, post, add, writeback, \
                      size=4, sign=False, user=False):
        name = mnem
        Name = storeRegClassName(post, add, writeback,
                                 size, sign, user)

        if add:
            op = " +"
        else:
            op = " -"

        offset = op + " shift_rm_imm(Index, shiftAmt," + \
                      " shiftType, CondCodes<29:>)"
        eaCode = "EA = Base"
        if not post:
            eaCode += offset
        eaCode += ";"

        accCode = "Mem%s = Dest;\n" % buildMemSuffix(sign, size)
        if writeback:
            accCode += "Base = Base %s;\n" % offset
        base = buildMemBase("MemoryReg", post, writeback)

        emitStore(name, Name, False, eaCode, accCode, [], [], base)

    def buildDoubleImmStore(mnem, post, add, writeback):
        name = mnem
        Name = storeDoubleImmClassName(post, add, writeback)

        if add:
            op = " +"
        else:
            op = " -"

        offset = op + " imm"
        eaCode = "EA = Base"
        if not post:
            eaCode += offset
        eaCode += ";"

        accCode = 'Mem.ud = (Dest.ud & mask(32)) | (Dest2.ud << 32);'
        if writeback:
            accCode += "Base = Base %s;\n" % offset
        base = buildMemBase("MemoryDImm", post, writeback)

        emitStore(name, Name, True, eaCode, accCode, \
                  [], [], base, double=True)

    def buildDoubleRegStore(mnem, post, add, writeback):
        name = mnem
        Name = storeDoubleRegClassName(post, add, writeback)

        if add:
            op = " +"
        else:
            op = " -"

        offset = op + " shift_rm_imm(Index, shiftAmt," + \
                      " shiftType, CondCodes<29:>)"
        eaCode = "EA = Base"
        if not post:
            eaCode += offset
        eaCode += ";"

        accCode = 'Mem.ud = (Dest.ud & mask(32)) | (Dest2.ud << 32);'
        if writeback:
            accCode += "Base = Base %s;\n" % offset
        base = buildMemBase("MemoryDReg", post, writeback)

        emitStore(name, Name, False, eaCode, accCode, \
                  [], [], base, double=True)

    def buildStores(mnem, size=4, sign=False, user=False):
        buildImmStore(mnem, True, True, True, size, sign, user)
        buildRegStore(mnem, True, True, True, size, sign, user)
        buildImmStore(mnem, True, False, True, size, sign, user)
        buildRegStore(mnem, True, False, True, size, sign, user)
        buildImmStore(mnem, False, True, True, size, sign, user)
        buildRegStore(mnem, False, True, True, size, sign, user)
        buildImmStore(mnem, False, False, True, size, sign, user)
        buildRegStore(mnem, False, False, True, size, sign, user)
        buildImmStore(mnem, False, True, False, size, sign, user)
        buildRegStore(mnem, False, True, False, size, sign, user)
        buildImmStore(mnem, False, False, False, size, sign, user)
        buildRegStore(mnem, False, False, False, size, sign, user)

    def buildDoubleStores(mnem):
        buildDoubleImmStore(mnem, True, True, True)
        buildDoubleRegStore(mnem, True, True, True)
        buildDoubleImmStore(mnem, True, False, True)
        buildDoubleRegStore(mnem, True, False, True)
        buildDoubleImmStore(mnem, False, True, True)
        buildDoubleRegStore(mnem, False, True, True)
        buildDoubleImmStore(mnem, False, False, True)
        buildDoubleRegStore(mnem, False, False, True)
        buildDoubleImmStore(mnem, False, True, False)
        buildDoubleRegStore(mnem, False, True, False)
        buildDoubleImmStore(mnem, False, False, False)
        buildDoubleRegStore(mnem, False, False, False)

    buildStores("str")
    buildStores("strt", user=True)
    buildStores("strb", size=1)
    buildStores("strbt", size=1, user=True)
    buildStores("strh", size=2)
    buildStores("strht", size=2, user=True)

    buildDoubleStores("strd")
}};
