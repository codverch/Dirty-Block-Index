// -*- mode:c++ -*-

// Copyright (c) 2010 ARM Limited
// All rights reserved
//
// The license below extends only to copyright in the software and shall
// not be construed as granting a license to any other intellectual
// property including but not limited to intellectual property relating
// to a hardware implementation of the functionality of the software
// licensed hereunder.  You may use the software subject to the license
// terms below provided that you ensure that this notice is replicated
// unmodified and in its entirety in all distributions of the software,
// modified or unmodified, in source code or in binary form.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer;
// redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution;
// neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Authors: Gabe Black

let {{

    header_output = ""
    decoder_output = ""
    exec_output = ""

    vmsrIop = InstObjParams("vmsr", "Vmsr", "RegRegOp",
                            { "code": "MiscDest = Op1;",
                              "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vmsrIop);
    decoder_output += RegRegOpConstructor.subst(vmsrIop);
    exec_output += PredOpExecute.subst(vmsrIop);

    vmrsIop = InstObjParams("vmrs", "Vmrs", "RegRegOp",
                            { "code": "Dest = MiscOp1;",
                              "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vmrsIop);
    decoder_output += RegRegOpConstructor.subst(vmrsIop);
    exec_output += PredOpExecute.subst(vmrsIop);

    vmovImmSCode = '''
        FpDest.uw = bits(imm, 31, 0);
    '''
    vmovImmSIop = InstObjParams("vmov", "VmovImmS", "RegImmOp",
                                { "code": vmovImmSCode,
                                  "predicate_test": predicateTest }, [])
    header_output += RegImmOpDeclare.subst(vmovImmSIop);
    decoder_output += RegImmOpConstructor.subst(vmovImmSIop);
    exec_output += PredOpExecute.subst(vmovImmSIop);

    vmovImmDCode = '''
        FpDestP0.uw = bits(imm, 31, 0);
        FpDestP1.uw = bits(imm, 63, 32);
    '''
    vmovImmDIop = InstObjParams("vmov", "VmovImmD", "RegImmOp",
                                { "code": vmovImmDCode,
                                  "predicate_test": predicateTest }, [])
    header_output += RegImmOpDeclare.subst(vmovImmDIop);
    decoder_output += RegImmOpConstructor.subst(vmovImmDIop);
    exec_output += PredOpExecute.subst(vmovImmDIop);

    vmovImmQCode = '''
        FpDestP0.uw = bits(imm, 31, 0);
        FpDestP1.uw = bits(imm, 63, 32);
        FpDestP2.uw = bits(imm, 31, 0);
        FpDestP3.uw = bits(imm, 63, 32);
    '''
    vmovImmQIop = InstObjParams("vmov", "VmovImmQ", "RegImmOp",
                                { "code": vmovImmQCode,
                                  "predicate_test": predicateTest }, [])
    header_output += RegImmOpDeclare.subst(vmovImmQIop);
    decoder_output += RegImmOpConstructor.subst(vmovImmQIop);
    exec_output += PredOpExecute.subst(vmovImmQIop);

    vmovRegSCode = '''
        FpDest.uw = FpOp1.uw;
    '''
    vmovRegSIop = InstObjParams("vmov", "VmovRegS", "RegRegOp",
                                { "code": vmovRegSCode,
                                  "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vmovRegSIop);
    decoder_output += RegRegOpConstructor.subst(vmovRegSIop);
    exec_output += PredOpExecute.subst(vmovRegSIop);

    vmovRegDCode = '''
        FpDestP0.uw = FpOp1P0.uw;
        FpDestP1.uw = FpOp1P1.uw;
    '''
    vmovRegDIop = InstObjParams("vmov", "VmovRegD", "RegRegOp",
                                { "code": vmovRegDCode,
                                  "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vmovRegDIop);
    decoder_output += RegRegOpConstructor.subst(vmovRegDIop);
    exec_output += PredOpExecute.subst(vmovRegDIop);

    vmovRegQCode = '''
        FpDestP0.uw = FpOp1P0.uw;
        FpDestP1.uw = FpOp1P1.uw;
        FpDestP2.uw = FpOp1P2.uw;
        FpDestP3.uw = FpOp1P3.uw;
    '''
    vmovRegQIop = InstObjParams("vmov", "VmovRegQ", "RegRegOp",
                                { "code": vmovRegQCode,
                                  "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vmovRegQIop);
    decoder_output += RegRegOpConstructor.subst(vmovRegQIop);
    exec_output += PredOpExecute.subst(vmovRegQIop);

    vmovCoreRegBCode = '''
        FpDest.uw = insertBits(FpDest.uw, imm * 8, imm * 8 + 7, Op1.ub);
    '''
    vmovCoreRegBIop = InstObjParams("vmov", "VmovCoreRegB", "RegRegImmOp",
                                    { "code": vmovCoreRegBCode,
                                      "predicate_test": predicateTest }, [])
    header_output += RegRegImmOpDeclare.subst(vmovCoreRegBIop);
    decoder_output += RegRegImmOpConstructor.subst(vmovCoreRegBIop);
    exec_output += PredOpExecute.subst(vmovCoreRegBIop);

    vmovCoreRegHCode = '''
        FpDest.uw = insertBits(FpDest.uw, imm * 16, imm * 16 + 15, Op1.uh);
    '''
    vmovCoreRegHIop = InstObjParams("vmov", "VmovCoreRegH", "RegRegImmOp",
                                    { "code": vmovCoreRegHCode,
                                      "predicate_test": predicateTest }, [])
    header_output += RegRegImmOpDeclare.subst(vmovCoreRegHIop);
    decoder_output += RegRegImmOpConstructor.subst(vmovCoreRegHIop);
    exec_output += PredOpExecute.subst(vmovCoreRegHIop);

    vmovCoreRegWCode = '''
        FpDest.uw = Op1.uw;
    '''
    vmovCoreRegWIop = InstObjParams("vmov", "VmovCoreRegW", "RegRegOp",
                                    { "code": vmovCoreRegWCode,
                                      "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vmovCoreRegWIop);
    decoder_output += RegRegOpConstructor.subst(vmovCoreRegWIop);
    exec_output += PredOpExecute.subst(vmovCoreRegWIop);

    vmovRegCoreUBCode = '''
        Dest = bits(FpOp1.uw, imm * 8, imm * 8 + 7);
    '''
    vmovRegCoreUBIop = InstObjParams("vmov", "VmovRegCoreUB", "RegRegImmOp",
                                     { "code": vmovRegCoreUBCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegImmOpDeclare.subst(vmovRegCoreUBIop);
    decoder_output += RegRegImmOpConstructor.subst(vmovRegCoreUBIop);
    exec_output += PredOpExecute.subst(vmovRegCoreUBIop);

    vmovRegCoreUHCode = '''
        Dest = bits(FpOp1.uw, imm * 16, imm * 16 + 15);
    '''
    vmovRegCoreUHIop = InstObjParams("vmov", "VmovRegCoreUH", "RegRegImmOp",
                                     { "code": vmovRegCoreUHCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegImmOpDeclare.subst(vmovRegCoreUHIop);
    decoder_output += RegRegImmOpConstructor.subst(vmovRegCoreUHIop);
    exec_output += PredOpExecute.subst(vmovRegCoreUHIop);

    vmovRegCoreSBCode = '''
        Dest = sext<8>(bits(FpOp1.uw, imm * 8, imm * 8 + 7));
    '''
    vmovRegCoreSBIop = InstObjParams("vmov", "VmovRegCoreSB", "RegRegImmOp",
                                     { "code": vmovRegCoreSBCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegImmOpDeclare.subst(vmovRegCoreSBIop);
    decoder_output += RegRegImmOpConstructor.subst(vmovRegCoreSBIop);
    exec_output += PredOpExecute.subst(vmovRegCoreSBIop);

    vmovRegCoreSHCode = '''
        Dest = sext<16>(bits(FpOp1.uw, imm * 16, imm * 16 + 15));
    '''
    vmovRegCoreSHIop = InstObjParams("vmov", "VmovRegCoreSH", "RegRegImmOp",
                                     { "code": vmovRegCoreSHCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegImmOpDeclare.subst(vmovRegCoreSHIop);
    decoder_output += RegRegImmOpConstructor.subst(vmovRegCoreSHIop);
    exec_output += PredOpExecute.subst(vmovRegCoreSHIop);

    vmovRegCoreWCode = '''
        Dest = FpOp1.uw;
    '''
    vmovRegCoreWIop = InstObjParams("vmov", "VmovRegCoreW", "RegRegOp",
                                     { "code": vmovRegCoreWCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vmovRegCoreWIop);
    decoder_output += RegRegOpConstructor.subst(vmovRegCoreWIop);
    exec_output += PredOpExecute.subst(vmovRegCoreWIop);

    vmov2Reg2CoreCode = '''
        FpDestP0.uw = Op1.uw;
        FpDestP1.uw = Op2.uw;
    '''
    vmov2Reg2CoreIop = InstObjParams("vmov", "Vmov2Reg2Core", "RegRegRegOp",
                                     { "code": vmov2Reg2CoreCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vmov2Reg2CoreIop);
    decoder_output += RegRegRegOpConstructor.subst(vmov2Reg2CoreIop);
    exec_output += PredOpExecute.subst(vmov2Reg2CoreIop);

    vmov2Core2RegCode = '''
        Dest.uw = FpOp2P0.uw;
        Op1.uw = FpOp2P1.uw;
    '''
    vmov2Core2RegIop = InstObjParams("vmov", "Vmov2Core2Reg", "RegRegRegOp",
                                     { "code": vmov2Core2RegCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vmov2Core2RegIop);
    decoder_output += RegRegRegOpConstructor.subst(vmov2Core2RegIop);
    exec_output += PredOpExecute.subst(vmov2Core2RegIop);

    vmulSCode = '''
        FpDest = FpOp1 * FpOp2;
        if ((isinf(FpOp1) && FpOp2 == 0) || (isinf(FpOp2) && FpOp1 == 0)) {
            FpDest = NAN;
        }
    '''
    vmulSIop = InstObjParams("vmuls", "VmulS", "RegRegRegOp",
                                     { "code": vmulSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vmulSIop);
    decoder_output += RegRegRegOpConstructor.subst(vmulSIop);
    exec_output += PredOpExecute.subst(vmulSIop);

    vmulDCode = '''
        IntDoubleUnion cOp1, cOp2, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cOp2.bits = ((uint64_t)FpOp2P0.uw | ((uint64_t)FpOp2P1.uw << 32));
        cDest.fp = cOp1.fp * cOp2.fp;
        if ((isinf(cOp1.fp) && cOp2.fp == 0) ||
                (isinf(cOp2.fp) && cOp1.fp == 0)) {
            cDest.fp = NAN;
        }
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vmulDIop = InstObjParams("vmuld", "VmulD", "RegRegRegOp",
                                     { "code": vmulDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vmulDIop);
    decoder_output += RegRegRegOpConstructor.subst(vmulDIop);
    exec_output += PredOpExecute.subst(vmulDIop);

    vnegSCode = '''
        FpDest = -FpOp1;
    '''
    vnegSIop = InstObjParams("vnegs", "VnegS", "RegRegOp",
                                     { "code": vnegSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vnegSIop);
    decoder_output += RegRegOpConstructor.subst(vnegSIop);
    exec_output += PredOpExecute.subst(vnegSIop);

    vnegDCode = '''
        IntDoubleUnion cOp1, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cDest.fp = -cOp1.fp;
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vnegDIop = InstObjParams("vnegd", "VnegD", "RegRegOp",
                                     { "code": vnegDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vnegDIop);
    decoder_output += RegRegOpConstructor.subst(vnegDIop);
    exec_output += PredOpExecute.subst(vnegDIop);

    vabsSCode = '''
        FpDest = fabsf(FpOp1);
    '''
    vabsSIop = InstObjParams("vabss", "VabsS", "RegRegOp",
                                     { "code": vabsSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vabsSIop);
    decoder_output += RegRegOpConstructor.subst(vabsSIop);
    exec_output += PredOpExecute.subst(vabsSIop);

    vabsDCode = '''
        IntDoubleUnion cOp1, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cDest.fp = fabs(cOp1.fp);
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vabsDIop = InstObjParams("vabsd", "VabsD", "RegRegOp",
                                     { "code": vabsDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vabsDIop);
    decoder_output += RegRegOpConstructor.subst(vabsDIop);
    exec_output += PredOpExecute.subst(vabsDIop);
}};
