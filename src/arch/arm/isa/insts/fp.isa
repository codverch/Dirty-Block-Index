// -*- mode:c++ -*-

// Copyright (c) 2010 ARM Limited
// All rights reserved
//
// The license below extends only to copyright in the software and shall
// not be construed as granting a license to any other intellectual
// property including but not limited to intellectual property relating
// to a hardware implementation of the functionality of the software
// licensed hereunder.  You may use the software subject to the license
// terms below provided that you ensure that this notice is replicated
// unmodified and in its entirety in all distributions of the software,
// modified or unmodified, in source code or in binary form.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer;
// redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution;
// neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Authors: Gabe Black

output header {{

template <class Micro>
class VfpMacroRegRegOp : public VfpMacroOp
{
  public:
    VfpMacroRegRegOp(ExtMachInst _machInst, IntRegIndex _dest,
                     IntRegIndex _op1, bool _wide) :
        VfpMacroOp("VfpMacroRegRegOp", _machInst, No_OpClass, _wide)
    {
        numMicroops = machInst.fpscrLen + 1;
        assert(numMicroops > 1);
        microOps = new StaticInstPtr[numMicroops];
        for (unsigned i = 0; i < numMicroops; i++) {
            VfpMicroMode mode = VfpMicroop;
            if (i == 0)
                mode = VfpFirstMicroop;
            else if (i == numMicroops - 1)
                mode = VfpLastMicroop;
            microOps[i] = new Micro(_machInst, _dest, _op1, mode);
            nextIdxs(_dest, _op1);
        }
    }

    %(BasicExecPanic)s
};

template <class VfpOp>
static StaticInstPtr
decodeVfpRegRegOp(ExtMachInst machInst,
        IntRegIndex dest, IntRegIndex op1, bool wide)
{
    if (machInst.fpscrLen == 0 || VfpMacroOp::inScalarBank(dest)) {
        return new VfpOp(machInst, dest, op1);
    } else {
        return new VfpMacroRegRegOp<VfpOp>(machInst, dest, op1, wide);
    }
}

template <class Micro>
class VfpMacroRegImmOp : public VfpMacroOp
{
  public:
    VfpMacroRegImmOp(ExtMachInst _machInst, IntRegIndex _dest, uint64_t _imm,
                     bool _wide) :
        VfpMacroOp("VfpMacroRegImmOp", _machInst, No_OpClass, _wide)
    {
        numMicroops = machInst.fpscrLen + 1;
        microOps = new StaticInstPtr[numMicroops];
        for (unsigned i = 0; i < numMicroops; i++) {
            VfpMicroMode mode = VfpMicroop;
            if (i == 0)
                mode = VfpFirstMicroop;
            else if (i == numMicroops - 1)
                mode = VfpLastMicroop;
            microOps[i] = new Micro(_machInst, _dest, _imm, mode);
            nextIdxs(_dest);
        }
    }

    %(BasicExecPanic)s
};

template <class VfpOp>
static StaticInstPtr
decodeVfpRegImmOp(ExtMachInst machInst,
        IntRegIndex dest, uint64_t imm, bool wide)
{
    if (machInst.fpscrLen == 0 || VfpMacroOp::inScalarBank(dest)) {
        return new VfpOp(machInst, dest, imm);
    } else {
        return new VfpMacroRegImmOp<VfpOp>(machInst, dest, imm, wide);
    }
}

template <class Micro>
class VfpMacroRegRegImmOp : public VfpMacroOp
{
  public:
    VfpMacroRegRegImmOp(ExtMachInst _machInst, IntRegIndex _dest,
                        IntRegIndex _op1, uint64_t _imm, bool _wide) :
        VfpMacroOp("VfpMacroRegRegImmOp", _machInst, No_OpClass, _wide)
    {
        numMicroops = machInst.fpscrLen + 1;
        microOps = new StaticInstPtr[numMicroops];
        for (unsigned i = 0; i < numMicroops; i++) {
            VfpMicroMode mode = VfpMicroop;
            if (i == 0)
                mode = VfpFirstMicroop;
            else if (i == numMicroops - 1)
                mode = VfpLastMicroop;
            microOps[i] = new Micro(_machInst, _dest, _op1, _imm, mode);
            nextIdxs(_dest, _op1);
        }
    }

    %(BasicExecPanic)s
};

template <class VfpOp>
static StaticInstPtr
decodeVfpRegRegImmOp(ExtMachInst machInst, IntRegIndex dest,
                     IntRegIndex op1, uint64_t imm, bool wide)
{
    if (machInst.fpscrLen == 0 || VfpMacroOp::inScalarBank(dest)) {
        return new VfpOp(machInst, dest, op1, imm);
    } else {
        return new VfpMacroRegRegImmOp<VfpOp>(machInst, dest, op1, imm, wide);
    }
}

template <class Micro>
class VfpMacroRegRegRegOp : public VfpMacroOp
{
  public:
    VfpMacroRegRegRegOp(ExtMachInst _machInst, IntRegIndex _dest,
                        IntRegIndex _op1, IntRegIndex _op2, bool _wide) :
        VfpMacroOp("VfpMacroRegRegRegOp", _machInst, No_OpClass, _wide)
    {
        numMicroops = machInst.fpscrLen + 1;
        microOps = new StaticInstPtr[numMicroops];
        for (unsigned i = 0; i < numMicroops; i++) {
            VfpMicroMode mode = VfpMicroop;
            if (i == 0)
                mode = VfpFirstMicroop;
            else if (i == numMicroops - 1)
                mode = VfpLastMicroop;
            microOps[i] = new Micro(_machInst, _dest, _op1, _op2, mode);
            nextIdxs(_dest, _op1, _op2);
        }
    }

    %(BasicExecPanic)s
};

template <class VfpOp>
static StaticInstPtr
decodeVfpRegRegRegOp(ExtMachInst machInst, IntRegIndex dest,
                     IntRegIndex op1, IntRegIndex op2, bool wide)
{
    if (machInst.fpscrLen == 0 || VfpMacroOp::inScalarBank(dest)) {
        return new VfpOp(machInst, dest, op1, op2);
    } else {
        return new VfpMacroRegRegRegOp<VfpOp>(machInst, dest, op1, op2, wide);
    }
}
}};

let {{

    header_output = ""
    decoder_output = ""
    exec_output = ""

    vmsrIop = InstObjParams("vmsr", "Vmsr", "VfpRegRegOp",
                            { "code": "MiscDest = Op1;",
                              "predicate_test": predicateTest }, [])
    header_output += VfpRegRegOpDeclare.subst(vmsrIop);
    decoder_output += VfpRegRegOpConstructor.subst(vmsrIop);
    exec_output += PredOpExecute.subst(vmsrIop);

    vmrsIop = InstObjParams("vmrs", "Vmrs", "VfpRegRegOp",
                            { "code": "Dest = MiscOp1;",
                              "predicate_test": predicateTest }, [])
    header_output += VfpRegRegOpDeclare.subst(vmrsIop);
    decoder_output += VfpRegRegOpConstructor.subst(vmrsIop);
    exec_output += PredOpExecute.subst(vmrsIop);

    vmovImmSCode = '''
        FpDest.uw = bits(imm, 31, 0);
    '''
    vmovImmSIop = InstObjParams("vmov", "VmovImmS", "VfpRegImmOp",
                                { "code": vmovImmSCode,
                                  "predicate_test": predicateTest }, [])
    header_output += VfpRegImmOpDeclare.subst(vmovImmSIop);
    decoder_output += VfpRegImmOpConstructor.subst(vmovImmSIop);
    exec_output += PredOpExecute.subst(vmovImmSIop);

    vmovImmDCode = '''
        FpDestP0.uw = bits(imm, 31, 0);
        FpDestP1.uw = bits(imm, 63, 32);
    '''
    vmovImmDIop = InstObjParams("vmov", "VmovImmD", "VfpRegImmOp",
                                { "code": vmovImmDCode,
                                  "predicate_test": predicateTest }, [])
    header_output += VfpRegImmOpDeclare.subst(vmovImmDIop);
    decoder_output += VfpRegImmOpConstructor.subst(vmovImmDIop);
    exec_output += PredOpExecute.subst(vmovImmDIop);

    vmovImmQCode = '''
        FpDestP0.uw = bits(imm, 31, 0);
        FpDestP1.uw = bits(imm, 63, 32);
        FpDestP2.uw = bits(imm, 31, 0);
        FpDestP3.uw = bits(imm, 63, 32);
    '''
    vmovImmQIop = InstObjParams("vmov", "VmovImmQ", "VfpRegImmOp",
                                { "code": vmovImmQCode,
                                  "predicate_test": predicateTest }, [])
    header_output += VfpRegImmOpDeclare.subst(vmovImmQIop);
    decoder_output += VfpRegImmOpConstructor.subst(vmovImmQIop);
    exec_output += PredOpExecute.subst(vmovImmQIop);

    vmovRegSCode = '''
        FpDest.uw = FpOp1.uw;
    '''
    vmovRegSIop = InstObjParams("vmov", "VmovRegS", "VfpRegRegOp",
                                { "code": vmovRegSCode,
                                  "predicate_test": predicateTest }, [])
    header_output += VfpRegRegOpDeclare.subst(vmovRegSIop);
    decoder_output += VfpRegRegOpConstructor.subst(vmovRegSIop);
    exec_output += PredOpExecute.subst(vmovRegSIop);

    vmovRegDCode = '''
        FpDestP0.uw = FpOp1P0.uw;
        FpDestP1.uw = FpOp1P1.uw;
    '''
    vmovRegDIop = InstObjParams("vmov", "VmovRegD", "VfpRegRegOp",
                                { "code": vmovRegDCode,
                                  "predicate_test": predicateTest }, [])
    header_output += VfpRegRegOpDeclare.subst(vmovRegDIop);
    decoder_output += VfpRegRegOpConstructor.subst(vmovRegDIop);
    exec_output += PredOpExecute.subst(vmovRegDIop);

    vmovRegQCode = '''
        FpDestP0.uw = FpOp1P0.uw;
        FpDestP1.uw = FpOp1P1.uw;
        FpDestP2.uw = FpOp1P2.uw;
        FpDestP3.uw = FpOp1P3.uw;
    '''
    vmovRegQIop = InstObjParams("vmov", "VmovRegQ", "VfpRegRegOp",
                                { "code": vmovRegQCode,
                                  "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegOpDeclare.subst(vmovRegQIop);
    decoder_output  += VfpRegRegOpConstructor.subst(vmovRegQIop);
    exec_output += PredOpExecute.subst(vmovRegQIop);

    vmovCoreRegBCode = '''
        FpDest.uw = insertBits(FpDest.uw, imm * 8, imm * 8 + 7, Op1.ub);
    '''
    vmovCoreRegBIop = InstObjParams("vmov", "VmovCoreRegB", "VfpRegRegImmOp",
                                    { "code": vmovCoreRegBCode,
                                      "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegImmOpDeclare.subst(vmovCoreRegBIop);
    decoder_output  += VfpRegRegImmOpConstructor.subst(vmovCoreRegBIop);
    exec_output += PredOpExecute.subst(vmovCoreRegBIop);

    vmovCoreRegHCode = '''
        FpDest.uw = insertBits(FpDest.uw, imm * 16, imm * 16 + 15, Op1.uh);
    '''
    vmovCoreRegHIop = InstObjParams("vmov", "VmovCoreRegH", "VfpRegRegImmOp",
                                    { "code": vmovCoreRegHCode,
                                      "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegImmOpDeclare.subst(vmovCoreRegHIop);
    decoder_output  += VfpRegRegImmOpConstructor.subst(vmovCoreRegHIop);
    exec_output += PredOpExecute.subst(vmovCoreRegHIop);

    vmovCoreRegWCode = '''
        FpDest.uw = Op1.uw;
    '''
    vmovCoreRegWIop = InstObjParams("vmov", "VmovCoreRegW", "VfpRegRegOp",
                                    { "code": vmovCoreRegWCode,
                                      "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegOpDeclare.subst(vmovCoreRegWIop);
    decoder_output  += VfpRegRegOpConstructor.subst(vmovCoreRegWIop);
    exec_output += PredOpExecute.subst(vmovCoreRegWIop);

    vmovRegCoreUBCode = '''
        Dest = bits(FpOp1.uw, imm * 8, imm * 8 + 7);
    '''
    vmovRegCoreUBIop = InstObjParams("vmov", "VmovRegCoreUB", "VfpRegRegImmOp",
                                     { "code": vmovRegCoreUBCode,
                                       "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegImmOpDeclare.subst(vmovRegCoreUBIop);
    decoder_output  += VfpRegRegImmOpConstructor.subst(vmovRegCoreUBIop);
    exec_output += PredOpExecute.subst(vmovRegCoreUBIop);

    vmovRegCoreUHCode = '''
        Dest = bits(FpOp1.uw, imm * 16, imm * 16 + 15);
    '''
    vmovRegCoreUHIop = InstObjParams("vmov", "VmovRegCoreUH", "VfpRegRegImmOp",
                                     { "code": vmovRegCoreUHCode,
                                       "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegImmOpDeclare.subst(vmovRegCoreUHIop);
    decoder_output  += VfpRegRegImmOpConstructor.subst(vmovRegCoreUHIop);
    exec_output += PredOpExecute.subst(vmovRegCoreUHIop);

    vmovRegCoreSBCode = '''
        Dest = sext<8>(bits(FpOp1.uw, imm * 8, imm * 8 + 7));
    '''
    vmovRegCoreSBIop = InstObjParams("vmov", "VmovRegCoreSB", "VfpRegRegImmOp",
                                     { "code": vmovRegCoreSBCode,
                                       "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegImmOpDeclare.subst(vmovRegCoreSBIop);
    decoder_output  += VfpRegRegImmOpConstructor.subst(vmovRegCoreSBIop);
    exec_output += PredOpExecute.subst(vmovRegCoreSBIop);

    vmovRegCoreSHCode = '''
        Dest = sext<16>(bits(FpOp1.uw, imm * 16, imm * 16 + 15));
    '''
    vmovRegCoreSHIop = InstObjParams("vmov", "VmovRegCoreSH", "VfpRegRegImmOp",
                                     { "code": vmovRegCoreSHCode,
                                       "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegImmOpDeclare.subst(vmovRegCoreSHIop);
    decoder_output  += VfpRegRegImmOpConstructor.subst(vmovRegCoreSHIop);
    exec_output += PredOpExecute.subst(vmovRegCoreSHIop);

    vmovRegCoreWCode = '''
        Dest = FpOp1.uw;
    '''
    vmovRegCoreWIop = InstObjParams("vmov", "VmovRegCoreW", "VfpRegRegOp",
                                     { "code": vmovRegCoreWCode,
                                       "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegOpDeclare.subst(vmovRegCoreWIop);
    decoder_output  += VfpRegRegOpConstructor.subst(vmovRegCoreWIop);
    exec_output += PredOpExecute.subst(vmovRegCoreWIop);

    vmov2Reg2CoreCode = '''
        FpDestP0.uw = Op1.uw;
        FpDestP1.uw = Op2.uw;
    '''
    vmov2Reg2CoreIop = InstObjParams("vmov", "Vmov2Reg2Core", "VfpRegRegRegOp",
                                     { "code": vmov2Reg2CoreCode,
                                       "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegRegOpDeclare.subst(vmov2Reg2CoreIop);
    decoder_output  += VfpRegRegRegOpConstructor.subst(vmov2Reg2CoreIop);
    exec_output += PredOpExecute.subst(vmov2Reg2CoreIop);

    vmov2Core2RegCode = '''
        Dest.uw = FpOp2P0.uw;
        Op1.uw = FpOp2P1.uw;
    '''
    vmov2Core2RegIop = InstObjParams("vmov", "Vmov2Core2Reg", "VfpRegRegRegOp",
                                     { "code": vmov2Core2RegCode,
                                       "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegRegOpDeclare.subst(vmov2Core2RegIop);
    decoder_output  += VfpRegRegRegOpConstructor.subst(vmov2Core2RegIop);
    exec_output += PredOpExecute.subst(vmov2Core2RegIop);

    vmulSCode = '''
        VfpSavedState state = prepVfpFpscr(Fpscr);
        FpDest = FpOp1 * FpOp2;
        Fpscr = setVfpFpscr(Fpscr, state);
        if ((isinf(FpOp1) && FpOp2 == 0) || (isinf(FpOp2) && FpOp1 == 0)) {
            FpDest = NAN;
        }
    '''
    vmulSIop = InstObjParams("vmuls", "VmulS", "VfpRegRegRegOp",
                                     { "code": vmulSCode,
                                       "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegRegOpDeclare.subst(vmulSIop);
    decoder_output  += VfpRegRegRegOpConstructor.subst(vmulSIop);
    exec_output += PredOpExecute.subst(vmulSIop);

    vmulDCode = '''
        IntDoubleUnion cOp1, cOp2, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cOp2.bits = ((uint64_t)FpOp2P0.uw | ((uint64_t)FpOp2P1.uw << 32));
        VfpSavedState state = prepVfpFpscr(Fpscr);
        cDest.fp = cOp1.fp * cOp2.fp;
        Fpscr = setVfpFpscr(Fpscr, state);
        if ((isinf(cOp1.fp) && cOp2.fp == 0) ||
                (isinf(cOp2.fp) && cOp1.fp == 0)) {
            cDest.fp = NAN;
        }
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vmulDIop = InstObjParams("vmuld", "VmulD", "VfpRegRegRegOp",
                                     { "code": vmulDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegRegOpDeclare.subst(vmulDIop);
    decoder_output += VfpRegRegRegOpConstructor.subst(vmulDIop);
    exec_output += PredOpExecute.subst(vmulDIop);

    vnegSCode = '''
        FpDest = -FpOp1;
    '''
    vnegSIop = InstObjParams("vnegs", "VnegS", "VfpRegRegOp",
                                     { "code": vnegSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegOpDeclare.subst(vnegSIop);
    decoder_output += VfpRegRegOpConstructor.subst(vnegSIop);
    exec_output += PredOpExecute.subst(vnegSIop);

    vnegDCode = '''
        IntDoubleUnion cOp1, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cDest.fp = -cOp1.fp;
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vnegDIop = InstObjParams("vnegd", "VnegD", "VfpRegRegOp",
                                     { "code": vnegDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegOpDeclare.subst(vnegDIop);
    decoder_output += VfpRegRegOpConstructor.subst(vnegDIop);
    exec_output += PredOpExecute.subst(vnegDIop);

    vabsSCode = '''
        FpDest = fabsf(FpOp1);
    '''
    vabsSIop = InstObjParams("vabss", "VabsS", "VfpRegRegOp",
                                     { "code": vabsSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegOpDeclare.subst(vabsSIop);
    decoder_output += VfpRegRegOpConstructor.subst(vabsSIop);
    exec_output += PredOpExecute.subst(vabsSIop);

    vabsDCode = '''
        IntDoubleUnion cOp1, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cDest.fp = fabs(cOp1.fp);
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vabsDIop = InstObjParams("vabsd", "VabsD", "VfpRegRegOp",
                                     { "code": vabsDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegOpDeclare.subst(vabsDIop);
    decoder_output += VfpRegRegOpConstructor.subst(vabsDIop);
    exec_output += PredOpExecute.subst(vabsDIop);

    vaddSCode = '''
        VfpSavedState state = prepVfpFpscr(Fpscr);
        FpDest = FpOp1 + FpOp2;
        Fpscr = setVfpFpscr(Fpscr, state);
    '''
    vaddSIop = InstObjParams("vadds", "VaddS", "VfpRegRegRegOp",
                                     { "code": vaddSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegRegOpDeclare.subst(vaddSIop);
    decoder_output += VfpRegRegRegOpConstructor.subst(vaddSIop);
    exec_output += PredOpExecute.subst(vaddSIop);

    vaddDCode = '''
        IntDoubleUnion cOp1, cOp2, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cOp2.bits = ((uint64_t)FpOp2P0.uw | ((uint64_t)FpOp2P1.uw << 32));
        VfpSavedState state = prepVfpFpscr(Fpscr);
        cDest.fp = cOp1.fp + cOp2.fp;
        Fpscr = setVfpFpscr(Fpscr, state);
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vaddDIop = InstObjParams("vaddd", "VaddD", "VfpRegRegRegOp",
                                     { "code": vaddDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegRegOpDeclare.subst(vaddDIop);
    decoder_output += VfpRegRegRegOpConstructor.subst(vaddDIop);
    exec_output += PredOpExecute.subst(vaddDIop);

    vsubSCode = '''
        VfpSavedState state = prepVfpFpscr(Fpscr);
        FpDest = FpOp1 - FpOp2;
        Fpscr = setVfpFpscr(Fpscr, state)
    '''
    vsubSIop = InstObjParams("vsubs", "VsubS", "VfpRegRegRegOp",
                                     { "code": vsubSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegRegOpDeclare.subst(vsubSIop);
    decoder_output += VfpRegRegRegOpConstructor.subst(vsubSIop);
    exec_output += PredOpExecute.subst(vsubSIop);

    vsubDCode = '''
        IntDoubleUnion cOp1, cOp2, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cOp2.bits = ((uint64_t)FpOp2P0.uw | ((uint64_t)FpOp2P1.uw << 32));
        VfpSavedState state = prepVfpFpscr(Fpscr);
        cDest.fp = cOp1.fp - cOp2.fp;
        Fpscr = setVfpFpscr(Fpscr, state);
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vsubDIop = InstObjParams("vsubd", "VsubD", "VfpRegRegRegOp",
                                     { "code": vsubDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegRegOpDeclare.subst(vsubDIop);
    decoder_output += VfpRegRegRegOpConstructor.subst(vsubDIop);
    exec_output += PredOpExecute.subst(vsubDIop);

    vdivSCode = '''
        VfpSavedState state = prepVfpFpscr(Fpscr);
        FpDest = FpOp1 / FpOp2;
        Fpscr = setVfpFpscr(Fpscr, state);
    '''
    vdivSIop = InstObjParams("vdivs", "VdivS", "VfpRegRegRegOp",
                                     { "code": vdivSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegRegOpDeclare.subst(vdivSIop);
    decoder_output += VfpRegRegRegOpConstructor.subst(vdivSIop);
    exec_output += PredOpExecute.subst(vdivSIop);

    vdivDCode = '''
        IntDoubleUnion cOp1, cOp2, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cOp2.bits = ((uint64_t)FpOp2P0.uw | ((uint64_t)FpOp2P1.uw << 32));
        VfpSavedState state = prepVfpFpscr(Fpscr);
        cDest.fp = cOp1.fp / cOp2.fp;
        Fpscr = setVfpFpscr(Fpscr, state);
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vdivDIop = InstObjParams("vdivd", "VdivD", "VfpRegRegRegOp",
                                     { "code": vdivDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegRegOpDeclare.subst(vdivDIop);
    decoder_output += VfpRegRegRegOpConstructor.subst(vdivDIop);
    exec_output += PredOpExecute.subst(vdivDIop);

    vsqrtSCode = '''
        VfpSavedState state = prepVfpFpscr(Fpscr);
        FpDest = sqrtf(FpOp1);
        Fpscr = setVfpFpscr(Fpscr, state);
        if (FpOp1 < 0) {
            FpDest = NAN;
        }
    '''
    vsqrtSIop = InstObjParams("vsqrts", "VsqrtS", "VfpRegRegOp",
                                     { "code": vsqrtSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegOpDeclare.subst(vsqrtSIop);
    decoder_output += VfpRegRegOpConstructor.subst(vsqrtSIop);
    exec_output += PredOpExecute.subst(vsqrtSIop);

    vsqrtDCode = '''
        IntDoubleUnion cOp1, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        VfpSavedState state = prepVfpFpscr(Fpscr);
        cDest.fp = sqrt(cOp1.fp);
        Fpscr = setVfpFpscr(Fpscr, state);
        if (cOp1.fp < 0) {
            cDest.fp = NAN;
        }
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vsqrtDIop = InstObjParams("vsqrtd", "VsqrtD", "VfpRegRegOp",
                                     { "code": vsqrtDCode,
                                       "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegOpDeclare.subst(vsqrtDIop);
    decoder_output  += VfpRegRegOpConstructor.subst(vsqrtDIop);
    exec_output += PredOpExecute.subst(vsqrtDIop);

    vmlaSCode = '''
        VfpSavedState state = prepVfpFpscr(Fpscr);
        float mid = FpOp1 * FpOp2;
        if ((isinf(FpOp1) && FpOp2 == 0) || (isinf(FpOp2) && FpOp1 == 0)) {
            mid = NAN;
        }
        FpDest = FpDest + mid;
        Fpscr = setVfpFpscr(Fpscr, state);
    '''
    vmlaSIop = InstObjParams("vmlas", "VmlaS", "VfpRegRegRegOp",
                                     { "code": vmlaSCode,
                                       "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegRegOpDeclare.subst(vmlaSIop);
    decoder_output  += VfpRegRegRegOpConstructor.subst(vmlaSIop);
    exec_output += PredOpExecute.subst(vmlaSIop);

    vmlaDCode = '''
        IntDoubleUnion cOp1, cOp2, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cOp2.bits = ((uint64_t)FpOp2P0.uw | ((uint64_t)FpOp2P1.uw << 32));
        cDest.bits = ((uint64_t)FpDestP0.uw | ((uint64_t)FpDestP1.uw << 32));
        VfpSavedState state = prepVfpFpscr(Fpscr);
        double mid = cOp1.fp * cOp2.fp;
        if ((isinf(cOp1.fp) && cOp2.fp == 0) ||
                (isinf(cOp2.fp) && cOp1.fp == 0)) {
            mid = NAN;
        }
        cDest.fp = cDest.fp + mid;
        Fpscr = setVfpFpscr(Fpscr, state);
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vmlaDIop = InstObjParams("vmlad", "VmlaD", "VfpRegRegRegOp",
                                     { "code": vmlaDCode,
                                       "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegRegOpDeclare.subst(vmlaDIop);
    decoder_output  += VfpRegRegRegOpConstructor.subst(vmlaDIop);
    exec_output += PredOpExecute.subst(vmlaDIop);

    vmlsSCode = '''
        VfpSavedState state = prepVfpFpscr(Fpscr);
        float mid = FpOp1 * FpOp2;
        if ((isinf(FpOp1) && FpOp2 == 0) || (isinf(FpOp2) && FpOp1 == 0)) {
            mid = NAN;
        }
        FpDest = FpDest - mid;
        Fpscr = setVfpFpscr(Fpscr, state);
    '''
    vmlsSIop = InstObjParams("vmlss", "VmlsS", "VfpRegRegRegOp",
                                     { "code": vmlsSCode,
                                       "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegRegOpDeclare.subst(vmlsSIop);
    decoder_output  += VfpRegRegRegOpConstructor.subst(vmlsSIop);
    exec_output += PredOpExecute.subst(vmlsSIop);

    vmlsDCode = '''
        IntDoubleUnion cOp1, cOp2, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cOp2.bits = ((uint64_t)FpOp2P0.uw | ((uint64_t)FpOp2P1.uw << 32));
        cDest.bits = ((uint64_t)FpDestP0.uw | ((uint64_t)FpDestP1.uw << 32));
        VfpSavedState state = prepVfpFpscr(Fpscr);
        double mid = cOp1.fp * cOp2.fp;
        if ((isinf(cOp1.fp) && cOp2.fp == 0) ||
                (isinf(cOp2.fp) && cOp1.fp == 0)) {
            mid = NAN;
        }
        cDest.fp = cDest.fp - mid;
        Fpscr = setVfpFpscr(Fpscr, state);
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vmlsDIop = InstObjParams("vmlsd", "VmlsD", "VfpRegRegRegOp",
                                     { "code": vmlsDCode,
                                       "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegRegOpDeclare.subst(vmlsDIop);
    decoder_output  += VfpRegRegRegOpConstructor.subst(vmlsDIop);
    exec_output += PredOpExecute.subst(vmlsDIop);

    vnmlaSCode = '''
        VfpSavedState state = prepVfpFpscr(Fpscr);
        float mid = FpOp1 * FpOp2;
        if ((isinf(FpOp1) && FpOp2 == 0) || (isinf(FpOp2) && FpOp1 == 0)) {
            mid = NAN;
        }
        FpDest = -FpDest - mid;
        Fpscr = setVfpFpscr(Fpscr, state);
    '''
    vnmlaSIop = InstObjParams("vnmlas", "VnmlaS", "VfpRegRegRegOp",
                                     { "code": vnmlaSCode,
                                       "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegRegOpDeclare.subst(vnmlaSIop);
    decoder_output  += VfpRegRegRegOpConstructor.subst(vnmlaSIop);
    exec_output += PredOpExecute.subst(vnmlaSIop);

    vnmlaDCode = '''
        IntDoubleUnion cOp1, cOp2, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cOp2.bits = ((uint64_t)FpOp2P0.uw | ((uint64_t)FpOp2P1.uw << 32));
        cDest.bits = ((uint64_t)FpDestP0.uw | ((uint64_t)FpDestP1.uw << 32));
        VfpSavedState state = prepVfpFpscr(Fpscr);
        double mid = cOp1.fp * cOp2.fp;
        if ((isinf(cOp1.fp) && cOp2.fp == 0) ||
                (isinf(cOp2.fp) && cOp1.fp == 0)) {
            mid = NAN;
        }
        cDest.fp = -cDest.fp - mid;
        Fpscr = setVfpFpscr(Fpscr, state);
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vnmlaDIop = InstObjParams("vnmlad", "VnmlaD", "VfpRegRegRegOp",
                                     { "code": vnmlaDCode,
                                       "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegRegOpDeclare.subst(vnmlaDIop);
    decoder_output  += VfpRegRegRegOpConstructor.subst(vnmlaDIop);
    exec_output += PredOpExecute.subst(vnmlaDIop);

    vnmlsSCode = '''
        VfpSavedState state = prepVfpFpscr(Fpscr);
        float mid = FpOp1 * FpOp2;
        if ((isinf(FpOp1) && FpOp2 == 0) || (isinf(FpOp2) && FpOp1 == 0)) {
            mid = NAN;
        }
        FpDest = -FpDest + mid;
        Fpscr = setVfpFpscr(Fpscr, state);
    '''
    vnmlsSIop = InstObjParams("vnmlss", "VnmlsS", "VfpRegRegRegOp",
                                     { "code": vnmlsSCode,
                                       "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegRegOpDeclare.subst(vnmlsSIop);
    decoder_output  += VfpRegRegRegOpConstructor.subst(vnmlsSIop);
    exec_output += PredOpExecute.subst(vnmlsSIop);

    vnmlsDCode = '''
        IntDoubleUnion cOp1, cOp2, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cOp2.bits = ((uint64_t)FpOp2P0.uw | ((uint64_t)FpOp2P1.uw << 32));
        cDest.bits = ((uint64_t)FpDestP0.uw | ((uint64_t)FpDestP1.uw << 32));
        VfpSavedState state = prepVfpFpscr(Fpscr);
        double mid = cOp1.fp * cOp2.fp;
        if ((isinf(cOp1.fp) && cOp2.fp == 0) ||
                (isinf(cOp2.fp) && cOp1.fp == 0)) {
            mid = NAN;
        }
        cDest.fp = -cDest.fp + mid;
        Fpscr = setVfpFpscr(Fpscr, state);
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vnmlsDIop = InstObjParams("vnmlsd", "VnmlsD", "VfpRegRegRegOp",
                                     { "code": vnmlsDCode,
                                       "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegRegOpDeclare.subst(vnmlsDIop);
    decoder_output  += VfpRegRegRegOpConstructor.subst(vnmlsDIop);
    exec_output += PredOpExecute.subst(vnmlsDIop);

    vnmulSCode = '''
        VfpSavedState state = prepVfpFpscr(Fpscr);
        float mid = FpOp1 * FpOp2;
        if ((isinf(FpOp1) && FpOp2 == 0) || (isinf(FpOp2) && FpOp1 == 0)) {
            mid = NAN;
        }
        FpDest = -mid;
        Fpscr = setVfpFpscr(Fpscr, state);
    '''
    vnmulSIop = InstObjParams("vnmuls", "VnmulS", "VfpRegRegRegOp",
                                     { "code": vnmulSCode,
                                       "predicate_test": predicateTest }, [])
    header_output  += VfpRegRegRegOpDeclare.subst(vnmulSIop);
    decoder_output  += VfpRegRegRegOpConstructor.subst(vnmulSIop);
    exec_output += PredOpExecute.subst(vnmulSIop);

    vnmulDCode = '''
        IntDoubleUnion cOp1, cOp2, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cOp2.bits = ((uint64_t)FpOp2P0.uw | ((uint64_t)FpOp2P1.uw << 32));
        cDest.bits = ((uint64_t)FpDestP0.uw | ((uint64_t)FpDestP1.uw << 32));
        VfpSavedState state = prepVfpFpscr(Fpscr);
        double mid = cOp1.fp * cOp2.fp;
        if ((isinf(cOp1.fp) && cOp2.fp == 0) ||
                (isinf(cOp2.fp) && cOp1.fp == 0)) {
            mid = NAN;
        }
        cDest.fp = -mid;
        Fpscr = setVfpFpscr(Fpscr, state);
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vnmulDIop = InstObjParams("vnmuld", "VnmulD", "VfpRegRegRegOp",
                                     { "code": vnmulDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegRegOpDeclare.subst(vnmulDIop);
    decoder_output += VfpRegRegRegOpConstructor.subst(vnmulDIop);
    exec_output += PredOpExecute.subst(vnmulDIop);

    vcvtUIntFpSCode = '''
        VfpSavedState state = prepVfpFpscr(Fpscr);
        FpDest = FpOp1.uw;
        Fpscr = setVfpFpscr(Fpscr, state);
    '''
    vcvtUIntFpSIop = InstObjParams("vcvt", "VcvtUIntFpS", "VfpRegRegOp",
                                     { "code": vcvtUIntFpSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegOpDeclare.subst(vcvtUIntFpSIop);
    decoder_output += VfpRegRegOpConstructor.subst(vcvtUIntFpSIop);
    exec_output += PredOpExecute.subst(vcvtUIntFpSIop);

    vcvtUIntFpDCode = '''
        IntDoubleUnion cDest;
        VfpSavedState state = prepVfpFpscr(Fpscr);
        cDest.fp = (uint64_t)FpOp1P0.uw;
        Fpscr = setVfpFpscr(Fpscr, state);
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vcvtUIntFpDIop = InstObjParams("vcvt", "VcvtUIntFpD", "VfpRegRegOp",
                                     { "code": vcvtUIntFpDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegOpDeclare.subst(vcvtUIntFpDIop);
    decoder_output += VfpRegRegOpConstructor.subst(vcvtUIntFpDIop);
    exec_output += PredOpExecute.subst(vcvtUIntFpDIop);

    vcvtSIntFpSCode = '''
        VfpSavedState state = prepVfpFpscr(Fpscr);
        FpDest = FpOp1.sw;
        Fpscr = setVfpFpscr(Fpscr, state);
    '''
    vcvtSIntFpSIop = InstObjParams("vcvt", "VcvtSIntFpS", "VfpRegRegOp",
                                     { "code": vcvtSIntFpSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegOpDeclare.subst(vcvtSIntFpSIop);
    decoder_output += VfpRegRegOpConstructor.subst(vcvtSIntFpSIop);
    exec_output += PredOpExecute.subst(vcvtSIntFpSIop);

    vcvtSIntFpDCode = '''
        IntDoubleUnion cDest;
        VfpSavedState state = prepVfpFpscr(Fpscr);
        cDest.fp = FpOp1P0.sw;
        Fpscr = setVfpFpscr(Fpscr, state);
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vcvtSIntFpDIop = InstObjParams("vcvt", "VcvtSIntFpD", "VfpRegRegOp",
                                     { "code": vcvtSIntFpDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegOpDeclare.subst(vcvtSIntFpDIop);
    decoder_output += VfpRegRegOpConstructor.subst(vcvtSIntFpDIop);
    exec_output += PredOpExecute.subst(vcvtSIntFpDIop);

    vcvtFpUIntSCode = '''
        VfpSavedState state = prepVfpFpscr(Fpscr);
        FpDest.uw = FpOp1;
        Fpscr = setVfpFpscr(Fpscr, state);
    '''
    vcvtFpUIntSIop = InstObjParams("vcvt", "VcvtFpUIntS", "VfpRegRegOp",
                                     { "code": vcvtFpUIntSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegOpDeclare.subst(vcvtFpUIntSIop);
    decoder_output += VfpRegRegOpConstructor.subst(vcvtFpUIntSIop);
    exec_output += PredOpExecute.subst(vcvtFpUIntSIop);

    vcvtFpUIntDCode = '''
        IntDoubleUnion cOp1;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        VfpSavedState state = prepVfpFpscr(Fpscr);
        uint64_t result = cOp1.fp;
        Fpscr = setVfpFpscr(Fpscr, state);
        FpDestP0.uw = result;
    '''
    vcvtFpUIntDIop = InstObjParams("vcvt", "VcvtFpUIntD", "VfpRegRegOp",
                                     { "code": vcvtFpUIntDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegOpDeclare.subst(vcvtFpUIntDIop);
    decoder_output += VfpRegRegOpConstructor.subst(vcvtFpUIntDIop);
    exec_output += PredOpExecute.subst(vcvtFpUIntDIop);

    vcvtFpSIntSCode = '''
        VfpSavedState state = prepVfpFpscr(Fpscr);
        FpDest.sw = FpOp1;
        Fpscr = setVfpFpscr(Fpscr, state);
    '''
    vcvtFpSIntSIop = InstObjParams("vcvt", "VcvtFpSIntS", "VfpRegRegOp",
                                     { "code": vcvtFpSIntSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegOpDeclare.subst(vcvtFpSIntSIop);
    decoder_output += VfpRegRegOpConstructor.subst(vcvtFpSIntSIop);
    exec_output += PredOpExecute.subst(vcvtFpSIntSIop);

    vcvtFpSIntDCode = '''
        IntDoubleUnion cOp1;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        VfpSavedState state = prepVfpFpscr(Fpscr);
        int64_t result = cOp1.fp;
        Fpscr = setVfpFpscr(Fpscr, state);
        FpDestP0.uw = result;
    '''
    vcvtFpSIntDIop = InstObjParams("vcvt", "VcvtFpSIntD", "VfpRegRegOp",
                                     { "code": vcvtFpSIntDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegOpDeclare.subst(vcvtFpSIntDIop);
    decoder_output += VfpRegRegOpConstructor.subst(vcvtFpSIntDIop);
    exec_output += PredOpExecute.subst(vcvtFpSIntDIop);

    vcvtFpSFpDCode = '''
        IntDoubleUnion cDest;
        VfpSavedState state = prepVfpFpscr(Fpscr);
        cDest.fp = FpOp1;
        Fpscr = setVfpFpscr(Fpscr, state);
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vcvtFpSFpDIop = InstObjParams("vcvt", "VcvtFpSFpD", "VfpRegRegOp",
                                     { "code": vcvtFpSFpDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegOpDeclare.subst(vcvtFpSFpDIop);
    decoder_output += VfpRegRegOpConstructor.subst(vcvtFpSFpDIop);
    exec_output += PredOpExecute.subst(vcvtFpSFpDIop);

    vcvtFpDFpSCode = '''
        IntDoubleUnion cOp1;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        VfpSavedState state = prepVfpFpscr(Fpscr);
        FpDest = cOp1.fp;
        Fpscr = setVfpFpscr(Fpscr, state);
    '''
    vcvtFpDFpSIop = InstObjParams("vcvt", "VcvtFpDFpS", "VfpRegRegOp",
                                     { "code": vcvtFpDFpSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegOpDeclare.subst(vcvtFpDFpSIop);
    decoder_output += VfpRegRegOpConstructor.subst(vcvtFpDFpSIop);
    exec_output += PredOpExecute.subst(vcvtFpDFpSIop);

    vcmpSCode = '''
        FPSCR fpscr = Fpscr;
        if (FpDest == FpOp1) {
            fpscr.n = 0; fpscr.z = 1; fpscr.c = 1; fpscr.v = 0;
        } else if (FpDest < FpOp1) {
            fpscr.n = 1; fpscr.z = 0; fpscr.c = 0; fpscr.v = 0;
        } else if (FpDest > FpOp1) {
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 0;
        } else {
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 1;
        }
        Fpscr = fpscr;
    '''
    vcmpSIop = InstObjParams("vcmps", "VcmpS", "VfpRegRegOp",
                                     { "code": vcmpSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegOpDeclare.subst(vcmpSIop);
    decoder_output += VfpRegRegOpConstructor.subst(vcmpSIop);
    exec_output += PredOpExecute.subst(vcmpSIop);

    vcmpDCode = '''
        IntDoubleUnion cOp1, cDest;
        cDest.bits = ((uint64_t)FpDestP0.uw | ((uint64_t)FpDestP1.uw << 32));
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        FPSCR fpscr = Fpscr;
        if (cDest.fp == cOp1.fp) {
            fpscr.n = 0; fpscr.z = 1; fpscr.c = 1; fpscr.v = 0;
        } else if (cDest.fp < cOp1.fp) {
            fpscr.n = 1; fpscr.z = 0; fpscr.c = 0; fpscr.v = 0;
        } else if (cDest.fp > cOp1.fp) {
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 0;
        } else {
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 1;
        }
        Fpscr = fpscr;
    '''
    vcmpDIop = InstObjParams("vcmpd", "VcmpD", "VfpRegRegOp",
                                     { "code": vcmpDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegRegOpDeclare.subst(vcmpDIop);
    decoder_output += VfpRegRegOpConstructor.subst(vcmpDIop);
    exec_output += PredOpExecute.subst(vcmpDIop);

    vcmpZeroSCode = '''
        FPSCR fpscr = Fpscr;
        if (FpDest == imm) {
            fpscr.n = 0; fpscr.z = 1; fpscr.c = 1; fpscr.v = 0;
        } else if (FpDest < imm) {
            fpscr.n = 1; fpscr.z = 0; fpscr.c = 0; fpscr.v = 0;
        } else if (FpDest > imm) {
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 0;
        } else {
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 1;
        }
        Fpscr = fpscr;
    '''
    vcmpZeroSIop = InstObjParams("vcmpZeros", "VcmpZeroS", "VfpRegImmOp",
                                     { "code": vcmpZeroSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegImmOpDeclare.subst(vcmpZeroSIop);
    decoder_output += VfpRegImmOpConstructor.subst(vcmpZeroSIop);
    exec_output += PredOpExecute.subst(vcmpZeroSIop);

    vcmpZeroDCode = '''
        IntDoubleUnion cDest;
        cDest.bits = ((uint64_t)FpDestP0.uw | ((uint64_t)FpDestP1.uw << 32));
        FPSCR fpscr = Fpscr;
        if (cDest.fp == imm) {
            fpscr.n = 0; fpscr.z = 1; fpscr.c = 1; fpscr.v = 0;
        } else if (cDest.fp < imm) {
            fpscr.n = 1; fpscr.z = 0; fpscr.c = 0; fpscr.v = 0;
        } else if (cDest.fp > imm) {
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 0;
        } else {
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 1;
        }
        Fpscr = fpscr;
    '''
    vcmpZeroDIop = InstObjParams("vcmpZerod", "VcmpZeroD", "VfpRegImmOp",
                                     { "code": vcmpZeroDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += VfpRegImmOpDeclare.subst(vcmpZeroDIop);
    decoder_output += VfpRegImmOpConstructor.subst(vcmpZeroDIop);
    exec_output += PredOpExecute.subst(vcmpZeroDIop);
}};
