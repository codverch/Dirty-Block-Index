// -*- mode:c++ -*-

// Copyright (c) 2010 ARM Limited
// All rights reserved
//
// The license below extends only to copyright in the software and shall
// not be construed as granting a license to any other intellectual
// property including but not limited to intellectual property relating
// to a hardware implementation of the functionality of the software
// licensed hereunder.  You may use the software subject to the license
// terms below provided that you ensure that this notice is replicated
// unmodified and in its entirety in all distributions of the software,
// modified or unmodified, in source code or in binary form.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer;
// redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution;
// neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Authors: Gabe Black

let {{

    header_output = ""
    decoder_output = ""
    exec_output = ""

    vmsrIop = InstObjParams("vmsr", "Vmsr", "RegRegOp",
                            { "code": "MiscDest = Op1;",
                              "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vmsrIop);
    decoder_output += RegRegOpConstructor.subst(vmsrIop);
    exec_output += PredOpExecute.subst(vmsrIop);

    vmrsIop = InstObjParams("vmrs", "Vmrs", "RegRegOp",
                            { "code": "Dest = MiscOp1;",
                              "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vmrsIop);
    decoder_output += RegRegOpConstructor.subst(vmrsIop);
    exec_output += PredOpExecute.subst(vmrsIop);

    vmovImmSCode = '''
        FpDest.uw = bits(imm, 31, 0);
    '''
    vmovImmSIop = InstObjParams("vmov", "VmovImmS", "RegImmOp",
                                { "code": vmovImmSCode,
                                  "predicate_test": predicateTest }, [])
    header_output += RegImmOpDeclare.subst(vmovImmSIop);
    decoder_output += RegImmOpConstructor.subst(vmovImmSIop);
    exec_output += PredOpExecute.subst(vmovImmSIop);

    vmovImmDCode = '''
        FpDestP0.uw = bits(imm, 31, 0);
        FpDestP1.uw = bits(imm, 63, 32);
    '''
    vmovImmDIop = InstObjParams("vmov", "VmovImmD", "RegImmOp",
                                { "code": vmovImmDCode,
                                  "predicate_test": predicateTest }, [])
    header_output += RegImmOpDeclare.subst(vmovImmDIop);
    decoder_output += RegImmOpConstructor.subst(vmovImmDIop);
    exec_output += PredOpExecute.subst(vmovImmDIop);

    vmovImmQCode = '''
        FpDestP0.uw = bits(imm, 31, 0);
        FpDestP1.uw = bits(imm, 63, 32);
        FpDestP2.uw = bits(imm, 31, 0);
        FpDestP3.uw = bits(imm, 63, 32);
    '''
    vmovImmQIop = InstObjParams("vmov", "VmovImmQ", "RegImmOp",
                                { "code": vmovImmQCode,
                                  "predicate_test": predicateTest }, [])
    header_output += RegImmOpDeclare.subst(vmovImmQIop);
    decoder_output += RegImmOpConstructor.subst(vmovImmQIop);
    exec_output += PredOpExecute.subst(vmovImmQIop);

    vmovRegSCode = '''
        FpDest.uw = FpOp1.uw;
    '''
    vmovRegSIop = InstObjParams("vmov", "VmovRegS", "RegRegOp",
                                { "code": vmovRegSCode,
                                  "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vmovRegSIop);
    decoder_output += RegRegOpConstructor.subst(vmovRegSIop);
    exec_output += PredOpExecute.subst(vmovRegSIop);

    vmovRegDCode = '''
        FpDestP0.uw = FpOp1P0.uw;
        FpDestP1.uw = FpOp1P1.uw;
    '''
    vmovRegDIop = InstObjParams("vmov", "VmovRegD", "RegRegOp",
                                { "code": vmovRegDCode,
                                  "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vmovRegDIop);
    decoder_output += RegRegOpConstructor.subst(vmovRegDIop);
    exec_output += PredOpExecute.subst(vmovRegDIop);

    vmovRegQCode = '''
        FpDestP0.uw = FpOp1P0.uw;
        FpDestP1.uw = FpOp1P1.uw;
        FpDestP2.uw = FpOp1P2.uw;
        FpDestP3.uw = FpOp1P3.uw;
    '''
    vmovRegQIop = InstObjParams("vmov", "VmovRegQ", "RegRegOp",
                                { "code": vmovRegQCode,
                                  "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vmovRegQIop);
    decoder_output += RegRegOpConstructor.subst(vmovRegQIop);
    exec_output += PredOpExecute.subst(vmovRegQIop);

    vmovCoreRegBCode = '''
        FpDest.uw = insertBits(FpDest.uw, imm * 8, imm * 8 + 7, Op1.ub);
    '''
    vmovCoreRegBIop = InstObjParams("vmov", "VmovCoreRegB", "RegRegImmOp",
                                    { "code": vmovCoreRegBCode,
                                      "predicate_test": predicateTest }, [])
    header_output += RegRegImmOpDeclare.subst(vmovCoreRegBIop);
    decoder_output += RegRegImmOpConstructor.subst(vmovCoreRegBIop);
    exec_output += PredOpExecute.subst(vmovCoreRegBIop);

    vmovCoreRegHCode = '''
        FpDest.uw = insertBits(FpDest.uw, imm * 16, imm * 16 + 15, Op1.uh);
    '''
    vmovCoreRegHIop = InstObjParams("vmov", "VmovCoreRegH", "RegRegImmOp",
                                    { "code": vmovCoreRegHCode,
                                      "predicate_test": predicateTest }, [])
    header_output += RegRegImmOpDeclare.subst(vmovCoreRegHIop);
    decoder_output += RegRegImmOpConstructor.subst(vmovCoreRegHIop);
    exec_output += PredOpExecute.subst(vmovCoreRegHIop);

    vmovCoreRegWCode = '''
        FpDest.uw = Op1.uw;
    '''
    vmovCoreRegWIop = InstObjParams("vmov", "VmovCoreRegW", "RegRegOp",
                                    { "code": vmovCoreRegWCode,
                                      "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vmovCoreRegWIop);
    decoder_output += RegRegOpConstructor.subst(vmovCoreRegWIop);
    exec_output += PredOpExecute.subst(vmovCoreRegWIop);

    vmovRegCoreUBCode = '''
        Dest = bits(FpOp1.uw, imm * 8, imm * 8 + 7);
    '''
    vmovRegCoreUBIop = InstObjParams("vmov", "VmovRegCoreUB", "RegRegImmOp",
                                     { "code": vmovRegCoreUBCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegImmOpDeclare.subst(vmovRegCoreUBIop);
    decoder_output += RegRegImmOpConstructor.subst(vmovRegCoreUBIop);
    exec_output += PredOpExecute.subst(vmovRegCoreUBIop);

    vmovRegCoreUHCode = '''
        Dest = bits(FpOp1.uw, imm * 16, imm * 16 + 15);
    '''
    vmovRegCoreUHIop = InstObjParams("vmov", "VmovRegCoreUH", "RegRegImmOp",
                                     { "code": vmovRegCoreUHCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegImmOpDeclare.subst(vmovRegCoreUHIop);
    decoder_output += RegRegImmOpConstructor.subst(vmovRegCoreUHIop);
    exec_output += PredOpExecute.subst(vmovRegCoreUHIop);

    vmovRegCoreSBCode = '''
        Dest = sext<8>(bits(FpOp1.uw, imm * 8, imm * 8 + 7));
    '''
    vmovRegCoreSBIop = InstObjParams("vmov", "VmovRegCoreSB", "RegRegImmOp",
                                     { "code": vmovRegCoreSBCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegImmOpDeclare.subst(vmovRegCoreSBIop);
    decoder_output += RegRegImmOpConstructor.subst(vmovRegCoreSBIop);
    exec_output += PredOpExecute.subst(vmovRegCoreSBIop);

    vmovRegCoreSHCode = '''
        Dest = sext<16>(bits(FpOp1.uw, imm * 16, imm * 16 + 15));
    '''
    vmovRegCoreSHIop = InstObjParams("vmov", "VmovRegCoreSH", "RegRegImmOp",
                                     { "code": vmovRegCoreSHCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegImmOpDeclare.subst(vmovRegCoreSHIop);
    decoder_output += RegRegImmOpConstructor.subst(vmovRegCoreSHIop);
    exec_output += PredOpExecute.subst(vmovRegCoreSHIop);

    vmovRegCoreWCode = '''
        Dest = FpOp1.uw;
    '''
    vmovRegCoreWIop = InstObjParams("vmov", "VmovRegCoreW", "RegRegOp",
                                     { "code": vmovRegCoreWCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vmovRegCoreWIop);
    decoder_output += RegRegOpConstructor.subst(vmovRegCoreWIop);
    exec_output += PredOpExecute.subst(vmovRegCoreWIop);

    vmov2Reg2CoreCode = '''
        FpDestP0.uw = Op1.uw;
        FpDestP1.uw = Op2.uw;
    '''
    vmov2Reg2CoreIop = InstObjParams("vmov", "Vmov2Reg2Core", "RegRegRegOp",
                                     { "code": vmov2Reg2CoreCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vmov2Reg2CoreIop);
    decoder_output += RegRegRegOpConstructor.subst(vmov2Reg2CoreIop);
    exec_output += PredOpExecute.subst(vmov2Reg2CoreIop);

    vmov2Core2RegCode = '''
        Dest.uw = FpOp2P0.uw;
        Op1.uw = FpOp2P1.uw;
    '''
    vmov2Core2RegIop = InstObjParams("vmov", "Vmov2Core2Reg", "RegRegRegOp",
                                     { "code": vmov2Core2RegCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vmov2Core2RegIop);
    decoder_output += RegRegRegOpConstructor.subst(vmov2Core2RegIop);
    exec_output += PredOpExecute.subst(vmov2Core2RegIop);

    vmulSCode = '''
        FpDest = FpOp1 * FpOp2;
        if ((isinf(FpOp1) && FpOp2 == 0) || (isinf(FpOp2) && FpOp1 == 0)) {
            FpDest = NAN;
        }
    '''
    vmulSIop = InstObjParams("vmuls", "VmulS", "RegRegRegOp",
                                     { "code": vmulSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vmulSIop);
    decoder_output += RegRegRegOpConstructor.subst(vmulSIop);
    exec_output += PredOpExecute.subst(vmulSIop);

    vmulDCode = '''
        IntDoubleUnion cOp1, cOp2, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cOp2.bits = ((uint64_t)FpOp2P0.uw | ((uint64_t)FpOp2P1.uw << 32));
        cDest.fp = cOp1.fp * cOp2.fp;
        if ((isinf(cOp1.fp) && cOp2.fp == 0) ||
                (isinf(cOp2.fp) && cOp1.fp == 0)) {
            cDest.fp = NAN;
        }
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vmulDIop = InstObjParams("vmuld", "VmulD", "RegRegRegOp",
                                     { "code": vmulDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vmulDIop);
    decoder_output += RegRegRegOpConstructor.subst(vmulDIop);
    exec_output += PredOpExecute.subst(vmulDIop);

    vnegSCode = '''
        FpDest = -FpOp1;
    '''
    vnegSIop = InstObjParams("vnegs", "VnegS", "RegRegOp",
                                     { "code": vnegSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vnegSIop);
    decoder_output += RegRegOpConstructor.subst(vnegSIop);
    exec_output += PredOpExecute.subst(vnegSIop);

    vnegDCode = '''
        IntDoubleUnion cOp1, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cDest.fp = -cOp1.fp;
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vnegDIop = InstObjParams("vnegd", "VnegD", "RegRegOp",
                                     { "code": vnegDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vnegDIop);
    decoder_output += RegRegOpConstructor.subst(vnegDIop);
    exec_output += PredOpExecute.subst(vnegDIop);

    vabsSCode = '''
        FpDest = fabsf(FpOp1);
    '''
    vabsSIop = InstObjParams("vabss", "VabsS", "RegRegOp",
                                     { "code": vabsSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vabsSIop);
    decoder_output += RegRegOpConstructor.subst(vabsSIop);
    exec_output += PredOpExecute.subst(vabsSIop);

    vabsDCode = '''
        IntDoubleUnion cOp1, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cDest.fp = fabs(cOp1.fp);
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vabsDIop = InstObjParams("vabsd", "VabsD", "RegRegOp",
                                     { "code": vabsDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vabsDIop);
    decoder_output += RegRegOpConstructor.subst(vabsDIop);
    exec_output += PredOpExecute.subst(vabsDIop);

    vaddSCode = '''
        FpDest = FpOp1 + FpOp2;
    '''
    vaddSIop = InstObjParams("vadds", "VaddS", "RegRegRegOp",
                                     { "code": vaddSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vaddSIop);
    decoder_output += RegRegRegOpConstructor.subst(vaddSIop);
    exec_output += PredOpExecute.subst(vaddSIop);

    vaddDCode = '''
        IntDoubleUnion cOp1, cOp2, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cOp2.bits = ((uint64_t)FpOp2P0.uw | ((uint64_t)FpOp2P1.uw << 32));
        cDest.fp = cOp1.fp + cOp2.fp;
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vaddDIop = InstObjParams("vaddd", "VaddD", "RegRegRegOp",
                                     { "code": vaddDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vaddDIop);
    decoder_output += RegRegRegOpConstructor.subst(vaddDIop);
    exec_output += PredOpExecute.subst(vaddDIop);

    vsubSCode = '''
        FpDest = FpOp1 - FpOp2;
    '''
    vsubSIop = InstObjParams("vsubs", "VsubS", "RegRegRegOp",
                                     { "code": vsubSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vsubSIop);
    decoder_output += RegRegRegOpConstructor.subst(vsubSIop);
    exec_output += PredOpExecute.subst(vsubSIop);

    vsubDCode = '''
        IntDoubleUnion cOp1, cOp2, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cOp2.bits = ((uint64_t)FpOp2P0.uw | ((uint64_t)FpOp2P1.uw << 32));
        cDest.fp = cOp1.fp - cOp2.fp;
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vsubDIop = InstObjParams("vsubd", "VsubD", "RegRegRegOp",
                                     { "code": vsubDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vsubDIop);
    decoder_output += RegRegRegOpConstructor.subst(vsubDIop);
    exec_output += PredOpExecute.subst(vsubDIop);

    vdivSCode = '''
        FpDest = FpOp1 / FpOp2;
    '''
    vdivSIop = InstObjParams("vdivs", "VdivS", "RegRegRegOp",
                                     { "code": vdivSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vdivSIop);
    decoder_output += RegRegRegOpConstructor.subst(vdivSIop);
    exec_output += PredOpExecute.subst(vdivSIop);

    vdivDCode = '''
        IntDoubleUnion cOp1, cOp2, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cOp2.bits = ((uint64_t)FpOp2P0.uw | ((uint64_t)FpOp2P1.uw << 32));
        cDest.fp = cOp1.fp / cOp2.fp;
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vdivDIop = InstObjParams("vdivd", "VdivD", "RegRegRegOp",
                                     { "code": vdivDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vdivDIop);
    decoder_output += RegRegRegOpConstructor.subst(vdivDIop);
    exec_output += PredOpExecute.subst(vdivDIop);

    vsqrtSCode = '''
        FpDest = sqrtf(FpOp1);
        if (FpOp1 < 0) {
            FpDest = NAN;
        }
    '''
    vsqrtSIop = InstObjParams("vsqrts", "VsqrtS", "RegRegOp",
                                     { "code": vsqrtSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vsqrtSIop);
    decoder_output += RegRegOpConstructor.subst(vsqrtSIop);
    exec_output += PredOpExecute.subst(vsqrtSIop);

    vsqrtDCode = '''
        IntDoubleUnion cOp1, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cDest.fp = sqrt(cOp1.fp);
        if (cOp1.fp < 0) {
            cDest.fp = NAN;
        }
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vsqrtDIop = InstObjParams("vsqrtd", "VsqrtD", "RegRegOp",
                                     { "code": vsqrtDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vsqrtDIop);
    decoder_output += RegRegOpConstructor.subst(vsqrtDIop);
    exec_output += PredOpExecute.subst(vsqrtDIop);

    vmlaSCode = '''
        float mid = FpOp1 * FpOp2;
        if ((isinf(FpOp1) && FpOp2 == 0) || (isinf(FpOp2) && FpOp1 == 0)) {
            mid = NAN;
        }
        FpDest = FpDest + mid;
    '''
    vmlaSIop = InstObjParams("vmlas", "VmlaS", "RegRegRegOp",
                                     { "code": vmlaSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vmlaSIop);
    decoder_output += RegRegRegOpConstructor.subst(vmlaSIop);
    exec_output += PredOpExecute.subst(vmlaSIop);

    vmlaDCode = '''
        IntDoubleUnion cOp1, cOp2, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cOp2.bits = ((uint64_t)FpOp2P0.uw | ((uint64_t)FpOp2P1.uw << 32));
        cDest.bits = ((uint64_t)FpDestP0.uw | ((uint64_t)FpDestP1.uw << 32));
        double mid = cOp1.fp * cOp2.fp;
        if ((isinf(cOp1.fp) && cOp2.fp == 0) ||
                (isinf(cOp2.fp) && cOp1.fp == 0)) {
            mid = NAN;
        }
        cDest.fp = cDest.fp + mid;
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vmlaDIop = InstObjParams("vmlad", "VmlaD", "RegRegRegOp",
                                     { "code": vmlaDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vmlaDIop);
    decoder_output += RegRegRegOpConstructor.subst(vmlaDIop);
    exec_output += PredOpExecute.subst(vmlaDIop);

    vmlsSCode = '''
        float mid = FpOp1 * FpOp2;
        if ((isinf(FpOp1) && FpOp2 == 0) || (isinf(FpOp2) && FpOp1 == 0)) {
            mid = NAN;
        }
        FpDest = FpDest - mid;
    '''
    vmlsSIop = InstObjParams("vmlss", "VmlsS", "RegRegRegOp",
                                     { "code": vmlsSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vmlsSIop);
    decoder_output += RegRegRegOpConstructor.subst(vmlsSIop);
    exec_output += PredOpExecute.subst(vmlsSIop);

    vmlsDCode = '''
        IntDoubleUnion cOp1, cOp2, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cOp2.bits = ((uint64_t)FpOp2P0.uw | ((uint64_t)FpOp2P1.uw << 32));
        cDest.bits = ((uint64_t)FpDestP0.uw | ((uint64_t)FpDestP1.uw << 32));
        double mid = cOp1.fp * cOp2.fp;
        if ((isinf(cOp1.fp) && cOp2.fp == 0) ||
                (isinf(cOp2.fp) && cOp1.fp == 0)) {
            mid = NAN;
        }
        cDest.fp = cDest.fp - mid;
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vmlsDIop = InstObjParams("vmlsd", "VmlsD", "RegRegRegOp",
                                     { "code": vmlsDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vmlsDIop);
    decoder_output += RegRegRegOpConstructor.subst(vmlsDIop);
    exec_output += PredOpExecute.subst(vmlsDIop);

    vnmlaSCode = '''
        float mid = FpOp1 * FpOp2;
        if ((isinf(FpOp1) && FpOp2 == 0) || (isinf(FpOp2) && FpOp1 == 0)) {
            mid = NAN;
        }
        FpDest = -FpDest - mid;
    '''
    vnmlaSIop = InstObjParams("vnmlas", "VnmlaS", "RegRegRegOp",
                                     { "code": vnmlaSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vnmlaSIop);
    decoder_output += RegRegRegOpConstructor.subst(vnmlaSIop);
    exec_output += PredOpExecute.subst(vnmlaSIop);

    vnmlaDCode = '''
        IntDoubleUnion cOp1, cOp2, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cOp2.bits = ((uint64_t)FpOp2P0.uw | ((uint64_t)FpOp2P1.uw << 32));
        cDest.bits = ((uint64_t)FpDestP0.uw | ((uint64_t)FpDestP1.uw << 32));
        double mid = cOp1.fp * cOp2.fp;
        if ((isinf(cOp1.fp) && cOp2.fp == 0) ||
                (isinf(cOp2.fp) && cOp1.fp == 0)) {
            mid = NAN;
        }
        cDest.fp = -cDest.fp - mid;
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vnmlaDIop = InstObjParams("vnmlad", "VnmlaD", "RegRegRegOp",
                                     { "code": vnmlaDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vnmlaDIop);
    decoder_output += RegRegRegOpConstructor.subst(vnmlaDIop);
    exec_output += PredOpExecute.subst(vnmlaDIop);

    vnmlsSCode = '''
        float mid = FpOp1 * FpOp2;
        if ((isinf(FpOp1) && FpOp2 == 0) || (isinf(FpOp2) && FpOp1 == 0)) {
            mid = NAN;
        }
        FpDest = -FpDest + mid;
    '''
    vnmlsSIop = InstObjParams("vnmlss", "VnmlsS", "RegRegRegOp",
                                     { "code": vnmlsSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vnmlsSIop);
    decoder_output += RegRegRegOpConstructor.subst(vnmlsSIop);
    exec_output += PredOpExecute.subst(vnmlsSIop);

    vnmlsDCode = '''
        IntDoubleUnion cOp1, cOp2, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cOp2.bits = ((uint64_t)FpOp2P0.uw | ((uint64_t)FpOp2P1.uw << 32));
        cDest.bits = ((uint64_t)FpDestP0.uw | ((uint64_t)FpDestP1.uw << 32));
        double mid = cOp1.fp * cOp2.fp;
        if ((isinf(cOp1.fp) && cOp2.fp == 0) ||
                (isinf(cOp2.fp) && cOp1.fp == 0)) {
            mid = NAN;
        }
        cDest.fp = -cDest.fp + mid;
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vnmlsDIop = InstObjParams("vnmlsd", "VnmlsD", "RegRegRegOp",
                                     { "code": vnmlsDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vnmlsDIop);
    decoder_output += RegRegRegOpConstructor.subst(vnmlsDIop);
    exec_output += PredOpExecute.subst(vnmlsDIop);

    vnmulSCode = '''
        float mid = FpOp1 * FpOp2;
        if ((isinf(FpOp1) && FpOp2 == 0) || (isinf(FpOp2) && FpOp1 == 0)) {
            mid = NAN;
        }
        FpDest = -mid;
    '''
    vnmulSIop = InstObjParams("vnmuls", "VnmulS", "RegRegRegOp",
                                     { "code": vnmulSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vnmulSIop);
    decoder_output += RegRegRegOpConstructor.subst(vnmulSIop);
    exec_output += PredOpExecute.subst(vnmulSIop);

    vnmulDCode = '''
        IntDoubleUnion cOp1, cOp2, cDest;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        cOp2.bits = ((uint64_t)FpOp2P0.uw | ((uint64_t)FpOp2P1.uw << 32));
        cDest.bits = ((uint64_t)FpDestP0.uw | ((uint64_t)FpDestP1.uw << 32));
        double mid = cOp1.fp * cOp2.fp;
        if ((isinf(cOp1.fp) && cOp2.fp == 0) ||
                (isinf(cOp2.fp) && cOp1.fp == 0)) {
            mid = NAN;
        }
        cDest.fp = -mid;
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vnmulDIop = InstObjParams("vnmuld", "VnmulD", "RegRegRegOp",
                                     { "code": vnmulDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegRegOpDeclare.subst(vnmulDIop);
    decoder_output += RegRegRegOpConstructor.subst(vnmulDIop);
    exec_output += PredOpExecute.subst(vnmulDIop);

    vcvtUIntFpSCode = '''
        FpDest = FpOp1.uw;
    '''
    vcvtUIntFpSIop = InstObjParams("vcvt", "VcvtUIntFpS", "RegRegOp",
                                     { "code": vcvtUIntFpSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vcvtUIntFpSIop);
    decoder_output += RegRegOpConstructor.subst(vcvtUIntFpSIop);
    exec_output += PredOpExecute.subst(vcvtUIntFpSIop);

    vcvtUIntFpDCode = '''
        IntDoubleUnion cDest;
        cDest.fp = (uint64_t)FpOp1P0.uw;
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vcvtUIntFpDIop = InstObjParams("vcvt", "VcvtUIntFpD", "RegRegOp",
                                     { "code": vcvtUIntFpDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vcvtUIntFpDIop);
    decoder_output += RegRegOpConstructor.subst(vcvtUIntFpDIop);
    exec_output += PredOpExecute.subst(vcvtUIntFpDIop);

    vcvtSIntFpSCode = '''
        FpDest = FpOp1.sw;
    '''
    vcvtSIntFpSIop = InstObjParams("vcvt", "VcvtSIntFpS", "RegRegOp",
                                     { "code": vcvtSIntFpSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vcvtSIntFpSIop);
    decoder_output += RegRegOpConstructor.subst(vcvtSIntFpSIop);
    exec_output += PredOpExecute.subst(vcvtSIntFpSIop);

    vcvtSIntFpDCode = '''
        IntDoubleUnion cDest;
        cDest.fp = FpOp1P0.sw;
        FpDestP0.uw = cDest.bits;
        FpDestP1.uw = cDest.bits >> 32;
    '''
    vcvtSIntFpDIop = InstObjParams("vcvt", "VcvtSIntFpD", "RegRegOp",
                                     { "code": vcvtSIntFpDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vcvtSIntFpDIop);
    decoder_output += RegRegOpConstructor.subst(vcvtSIntFpDIop);
    exec_output += PredOpExecute.subst(vcvtSIntFpDIop);

    vcvtFpUIntSCode = '''
        FpDest.uw = FpOp1;
    '''
    vcvtFpUIntSIop = InstObjParams("vcvt", "VcvtFpUIntS", "RegRegOp",
                                     { "code": vcvtFpUIntSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vcvtFpUIntSIop);
    decoder_output += RegRegOpConstructor.subst(vcvtFpUIntSIop);
    exec_output += PredOpExecute.subst(vcvtFpUIntSIop);

    vcvtFpUIntDCode = '''
        IntDoubleUnion cOp1;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        uint64_t result = cOp1.fp;
        FpDestP0.uw = result;
    '''
    vcvtFpUIntDIop = InstObjParams("vcvt", "VcvtFpUIntD", "RegRegOp",
                                     { "code": vcvtFpUIntDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vcvtFpUIntDIop);
    decoder_output += RegRegOpConstructor.subst(vcvtFpUIntDIop);
    exec_output += PredOpExecute.subst(vcvtFpUIntDIop);

    vcvtFpSIntSCode = '''
        FpDest.sw = FpOp1;
    '''
    vcvtFpSIntSIop = InstObjParams("vcvt", "VcvtFpSIntS", "RegRegOp",
                                     { "code": vcvtFpSIntSCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vcvtFpSIntSIop);
    decoder_output += RegRegOpConstructor.subst(vcvtFpSIntSIop);
    exec_output += PredOpExecute.subst(vcvtFpSIntSIop);

    vcvtFpSIntDCode = '''
        IntDoubleUnion cOp1;
        cOp1.bits = ((uint64_t)FpOp1P0.uw | ((uint64_t)FpOp1P1.uw << 32));
        int64_t result = cOp1.fp;
        FpDestP0.uw = result;
    '''
    vcvtFpSIntDIop = InstObjParams("vcvt", "VcvtFpSIntD", "RegRegOp",
                                     { "code": vcvtFpSIntDCode,
                                       "predicate_test": predicateTest }, [])
    header_output += RegRegOpDeclare.subst(vcvtFpSIntDIop);
    decoder_output += RegRegOpConstructor.subst(vcvtFpSIntDIop);
    exec_output += PredOpExecute.subst(vcvtFpSIntDIop);
}};
