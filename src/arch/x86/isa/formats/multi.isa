// -*- mode:c++ -*-

// Copyright (c) 2007 The Hewlett-Packard Development Company
// All rights reserved.
//
// Redistribution and use of this software in source and binary forms,
// with or without modification, are permitted provided that the
// following conditions are met:
//
// The software must be used only for Non-Commercial Use which means any
// use which is NOT directed to receiving any direct monetary
// compensation for, or commercial advantage from such use.  Illustrative
// examples of non-commercial use are academic research, personal study,
// teaching, education and corporate research & development.
// Illustrative examples of commercial use are distributing products for
// commercial advantage and providing services using the software for
// commercial advantage.
//
// If you wish to use this software or functionality therein that may be
// covered by patents for commercial use, please contact:
//     Director of Intellectual Property Licensing
//     Office of Strategy and Technology
//     Hewlett-Packard Company
//     1501 Page Mill Road
//     Palo Alto, California  94304
//
// Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.  Redistributions
// in binary form must reproduce the above copyright notice, this list of
// conditions and the following disclaimer in the documentation and/or
// other materials provided with the distribution.  Neither the name of
// the COPYRIGHT HOLDER(s), HEWLETT-PACKARD COMPANY, nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.  No right of
// sublicense is granted herewith.  Derivatives of the software and
// output created using the software may be prepared, but only for
// Non-Commercial Uses.  Derivatives of the software may be shared with
// others provided: (i) the others agree to abide by the list of
// conditions herein which includes the Non-Commercial Use restrictions;
// and (ii) such Derivatives of the software include the above copyright
// notice to acknowledge the contribution from this software where
// applicable, this list of conditions and the disclaimer below.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Authors: Gabe Black

////////////////////////////////////////////////////////////////////
//
// Instructions that do the same thing to multiple sets of arguments.
//

let {{
    # This builds either a regular or macro op to implement the sequence of
    # ops we give it.
    def genInst(name, Name, ops):
        # If we can implement this instruction with exactly one microop, just
        # use that directly.
        newStmnt = ''
        if len(ops) == 1:
            decode_block = "return (X86StaticInst *)(%s);" % \
                            ops[0].getAllocator()
            return ('', '', decode_block, '')
        else:
            # Build a macroop to contain the sequence of microops we've
            # been given.
            return genMacroOp(name, Name, ops)
}};

let {{
    # This code builds up a decode block which decodes based on switchval.
    # vals is a dict which matches case values with what should be decoded to.
    # builder is called on the exploded contents of "vals" values to generate
    # whatever code should be used.
    def doMultiOp(name, Name, builder, switchVal, vals, default = None):
        header_output = ''
        decoder_output = ''
        decode_block = 'switch(%s) {\n' % switchVal
        exec_output = ''
        for (val, todo) in vals.items():
            (new_header_output,
             new_decoder_output,
             new_decode_block,
             new_exec_output) = builder(name, Name, *todo)
            header_output += new_header_output
            decoder_output += new_decoder_output
            decode_block += '\tcase %s: %s\n' % (val, new_decode_block)
            exec_output += new_exec_output
        if default:
            (new_header_output,
             new_decoder_output,
             new_decode_block,
             new_exec_output) = builder(name, Name, *default)
            header_output += new_header_output
            decoder_output += new_decoder_output
            decode_block += '\tdefault: %s\n' % new_decode_block
            exec_output += new_exec_output
        decode_block += '}\n'
        return (header_output, decoder_output, decode_block, exec_output)
}};

let {{

    # This function specializes the given piece of code to use a particular
    # set of argument types described by "opTags". These are "implemented"
    # in reverse order.
    def doCompOps(name, Name, code, opTags, postfix):
        opNum = len(opTags) - 1
        while len(opTags):
            # print "Building a composite op with tags", opTags
            # print "And code", code
            opNum = len(opTags) - 1
            # A regular expression to find the operand placeholders we're
            # interested in.
            opRe = re.compile("%%(?P<operandNum>%d)(?=[^0-9]|$)" % opNum)
            tag = opTags[opNum]
            # Build up a name for this instructions class using the argument
            # types. Each variation will get its own name this way.
            postfix = '_' + tag + postfix
            tagParser = re.compile(r"(?P<tagType>[A-Z][A-Z]*)(?P<tagSize>[a-z][a-z]*)|(r(?P<tagReg>[A-Za-z0-9][A-Za-z0-9]*))")
            tagMatch = tagParser.search(tag)
            if tagMatch == None:
                raise Exception, "Problem parsing operand tag %s" % tag
            reg = tagMatch.group("tagReg")
            tagType = tagMatch.group("tagType")
            tagSize = tagMatch.group("tagSize")
            if reg:
                #Figure out what to do with fixed register operands
                if reg in ("Ax", "Bx", "Cx", "Dx"):
                    code = opRe.sub("{INTREG_R%s}" % reg.upper(), code)
                elif reg == "Al":
                    # We need a way to specify register width
                    code = opRe.sub("{INTREG_RAX}", code)
                else:
                    print "Didn't know how to encode fixed register %s!" % reg
            elif tagType == None or tagSize == None:
                raise Exception, "Problem parsing operand tag: %s" % tag
            elif tagType == "C" or tagType == "D" or tagType == "G" or \
                                   tagType == "P" or tagType == "S" or \
                                   tagType == "T" or tagType == "V":
                # Use the "reg" field of the ModRM byte to select the register
                code = opRe.sub("{(uint8_t)MODRM_REG}", code)
            elif tagType == "E" or tagType == "Q" or tagType == "W":
                # This might refer to memory or to a register. We need to
                # divide it up farther.
                regCode = opRe.sub("{(uint8_t)MODRM_RM}", code)
                regTags = copy.copy(opTags)
                regTags.pop(-1)
                # This needs to refer to memory, but we'll fill in the details
                # later. It needs to take into account unaligned memory
                # addresses.
                memCode = opRe.sub("0", code)
                memTags = copy.copy(opTags)
                memTags.pop(-1)
                return doMultiOp(name, Name, doCompOps, "MODRM_MOD",
                    {"3" : (regCode, regTags, postfix)},
                           (memCode, memTags, postfix))
            elif tagType == "I" or tagType == "J":
                # Substitute in an immediate
                code = opRe.sub("{IMMEDIATE}", code)
            elif tagType == "M":
                # This needs to refer to memory, but we'll fill in the details
                # later. It needs to take into account unaligned memory
                # addresses.
                code = opRe.sub("0", code)
            elif tagType == "PR" or tagType == "R" or tagType == "VR":
                # There should probably be a check here to verify that mod
                # is equal to 11b
                code = opRe.sub("{(uint8_t)MODRM_RM}", code)
            else:
                raise Exception, "Unrecognized tag %s." % tag
            opTags.pop(-1)

        # At this point, we've built up "code" to have all the necessary extra
        # instructions needed to implement whatever types of operands were
        # specified. Now we'll assemble it it into a microOp sequence.
        ops = assembleMicro(code)

        # Build a macroop to contain the sequence of microops we've
        # constructed. The decode block will be used to fill in our
        # inner decode structure, and the rest will be concatenated and
        # passed back.
        return genInst(name, Name + postfix, ops)
}};

def format TaggedOp(code, tagSet) {{
    (header_output,
     decoder_output,
     decode_block,
     exec_output) = doCompOps(name, Name, code, tagSet, '')
}};

def format MultiOp(code, switchVal, opTags, *opt_flags) {{
    switcher = {}
    for (count, tagSet) in zip(xrange(len(opTags) - 1), opTags):
        switcher[count] = (code, tagSet, '')
    (header_output,
     decoder_output,
     decode_block,
     exec_output) = doMultiOp(name, Name, doCompOps, switchVal, switcher)
}};
