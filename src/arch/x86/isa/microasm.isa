// -*- mode:c++ -*-

// Copyright (c) 2007 The Hewlett-Packard Development Company
// All rights reserved.
//
// Redistribution and use of this software in source and binary forms,
// with or without modification, are permitted provided that the
// following conditions are met:
//
// The software must be used only for Non-Commercial Use which means any
// use which is NOT directed to receiving any direct monetary
// compensation for, or commercial advantage from such use.  Illustrative
// examples of non-commercial use are academic research, personal study,
// teaching, education and corporate research & development.
// Illustrative examples of commercial use are distributing products for
// commercial advantage and providing services using the software for
// commercial advantage.
//
// If you wish to use this software or functionality therein that may be
// covered by patents for commercial use, please contact:
//     Director of Intellectual Property Licensing
//     Office of Strategy and Technology
//     Hewlett-Packard Company
//     1501 Page Mill Road
//     Palo Alto, California  94304
//
// Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.  Redistributions
// in binary form must reproduce the above copyright notice, this list of
// conditions and the following disclaimer in the documentation and/or
// other materials provided with the distribution.  Neither the name of
// the COPYRIGHT HOLDER(s), HEWLETT-PACKARD COMPANY, nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.  No right of
// sublicense is granted herewith.  Derivatives of the software and
// output created using the software may be prepared, but only for
// Non-Commercial Uses.  Derivatives of the software may be shared with
// others provided: (i) the others agree to abide by the list of
// conditions herein which includes the Non-Commercial Use restrictions;
// and (ii) such Derivatives of the software include the above copyright
// notice to acknowledge the contribution from this software where
// applicable, this list of conditions and the disclaimer below.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Authors: Gabe Black

////////////////////////////////////////////////////////////////////
//
//  Code to "specialize" a microcode sequence to use a particular
//  variety of operands
//

let {{
    # This code builds up a decode block which decodes based on switchval.
    # vals is a dict which matches case values with what should be decoded to.
    # builder is called on the exploded contents of "vals" values to generate
    # whatever code should be used.
    def doSplitDecode(name, Name, builder, switchVal, vals, default = None):
        header_output = ''
        decoder_output = ''
        decode_block = 'switch(%s) {\n' % switchVal
        exec_output = ''
        for (val, todo) in vals.items():
            (new_header_output,
             new_decoder_output,
             new_decode_block,
             new_exec_output) = builder(name, Name, *todo)
            header_output += new_header_output
            decoder_output += new_decoder_output
            decode_block += '\tcase %s: %s\n' % (val, new_decode_block)
            exec_output += new_exec_output
        if default:
            (new_header_output,
             new_decoder_output,
             new_decode_block,
             new_exec_output) = builder(name, Name, *default)
            header_output += new_header_output
            decoder_output += new_decoder_output
            decode_block += '\tdefault: %s\n' % new_decode_block
            exec_output += new_exec_output
        decode_block += '}\n'
        return (header_output, decoder_output, decode_block, exec_output)
}};

let {{
    class OpType(object):
        parser = re.compile(r"(?P<tag>[A-Z][A-Z]*)(?P<size>[a-z][a-z]*)|(r(?P<reg>[A-Za-z0-9][A-Za-z0-9]*))")
        def __init__(self, opTypeString):
            match = OpType.parser.search(opTypeString)
            if match == None:
                raise Exception, "Problem parsing operand type %s" % opTypeString
            self.reg = match.group("reg")
            self.tag = match.group("tag")
            self.size = match.group("size")
}};

let {{

    # This function specializes the given piece of code to use a particular
    # set of argument types described by "opTypes". These are "implemented"
    # in reverse order.
    def specializeInst(name, Name, code, opTypes):
        opNum = len(opTypes) - 1
        while len(opTypes):
            # print "Building a composite op with tags", opTypes
            # print "And code", code
            opNum = len(opTypes) - 1
            # A regular expression to find the operand placeholders we're
            # interested in.
            opRe = re.compile("\\^(?P<operandNum>%d)(?=[^0-9]|$)" % opNum)

            # Parse the operand type strign we're working with
            opType = OpType(opTypes[opNum])

            if opType.reg:
                #Figure out what to do with fixed register operands
                if opType.reg in ("Ax", "Bx", "Cx", "Dx"):
                    code = opRe.sub("%%{INTREG_R%s}" % opType.reg.upper(), code)
                elif opType.reg == "Al":
                    # We need a way to specify register width
                    code = opRe.sub("%{INTREG_RAX}", code)
                else:
                    print "Didn't know how to encode fixed register %s!" % opType.reg
            elif opType.tag == None or opType.size == None:
                raise Exception, "Problem parsing operand tag: %s" % opType.tag
            elif opType.tag in ("C", "D", "G", "P", "S", "T", "V"):
                # Use the "reg" field of the ModRM byte to select the register
                code = opRe.sub("%{(uint8_t)MODRM_REG}", code)
            elif opType.tag in ("E", "Q", "W"):
                # This might refer to memory or to a register. We need to
                # divide it up farther.
                regCode = opRe.sub("%{(uint8_t)MODRM_RM}", code)
                regTypes = copy.copy(opTypes)
                regTypes.pop(-1)
                # This needs to refer to memory, but we'll fill in the details
                # later. It needs to take into account unaligned memory
                # addresses.
                memCode = opRe.sub("%0", code)
                memTypes = copy.copy(opTypes)
                memTypes.pop(-1)
                return doSplitDecode(name, Name, specializeInst, "MODRM_MOD",
                    {"3" : (regCode, regTypes)}, (memCode, memTypes))
            elif opType.tag in ("I", "J"):
                # Immediates are already in the instruction, so don't leave in
                # those parameters
                code = opRe.sub("${IMMEDIATE}", code)
            elif opType.tag == "M":
                # This needs to refer to memory, but we'll fill in the details
                # later. It needs to take into account unaligned memory
                # addresses.
                code = opRe.sub("%0", code)
            elif opType.tag in ("PR", "R", "VR"):
                # There should probably be a check here to verify that mod
                # is equal to 11b
                code = opRe.sub("%{(uint8_t)MODRM_RM}", code)
            else:
                raise Exception, "Unrecognized tag %s." % opType.tag
            opTypes.pop(-1)

        # At this point, we've built up "code" to have all the necessary extra
        # instructions needed to implement whatever types of operands were
        # specified. Now we'll assemble it it into a StaticInst.
        return assembleMicro(name, Name, code)
}};

////////////////////////////////////////////////////////////////////
//
//  The microcode assembler
//

let {{
    # These are used when setting up microops so that they can specialize their
    # base class template properly.
    RegOpType = "RegisterOperand"
    ImmOpType = "ImmediateOperand"
}};

let {{
    class MicroOpStatement(object):
        def __init__(self):
            self.className = ''
            self.label = ''
            self.args = []

        # This converts a list of python bools into
        # a comma seperated list of C++ bools.
        def microFlagsText(self, vals):
            text = ""
            for val in vals:
                if val:
                    text += ", true"
                else:
                    text += ", false"
            return text

        def getAllocator(self, *microFlags):
            args = ''
            signature = "<"
            emptySig = True
            for arg in self.args:
                if not emptySig:
                    signature += ", "
                emptySig = False
                if arg.has_key("operandImm"):
                    args += ", %s" % arg["operandImm"]
                    signature += ImmOpType
                elif arg.has_key("operandReg"):
                    args += ", %s" % arg["operandReg"]
                    signature += RegOpType
                elif arg.has_key("operandLabel"):
                    raise Exception, "Found a label while creating allocator string."
                else:
                    raise Exception, "Unrecognized operand type."
            signature += ">"
            return 'new %s%s(machInst%s%s)' % (self.className, signature, self.microFlagsText(microFlags), args)
}};

let{{
    def assembleMicro(name, Name, code):

        # This function takes in a block of microcode assembly and returns
        # a python list of objects which describe it.

        # Keep this around in case we need it later
        orig_code = code
        # A list of the statements we've found thus far
        statements = []

        # Regular expressions to pull each piece of the statement out at a
        # time. Each expression expects the thing it's looking for to be at
        # the beginning of the line, so the previous component is stripped
        # before continuing.
        labelRe = re.compile(r'^[ \t]*(?P<label>\w\w*)[ \t]:')
        lineRe = re.compile(r'^(?P<line>[^\n][^\n]*)$')
        classRe = re.compile(r'^[ \t]*(?P<className>[a-zA-Z_]\w*)')
        # This recognizes three different flavors of operands:
        # 1. Raw decimal numbers composed of digits between 0 and 9
        # 2. Code beginning with "{" and continuing until the first "}"
        #         ^ This one might need revising
        # 3. A label, which starts with a capital or small letter, or
        #    underscore, which is optionally followed by a sequence of
        #    capital or small letters, underscores, or digts between 0 and 9
        opRe = re.compile( \
            r'^[ \t]*((\@(?P<operandLabel0>\w\w*))|' +
                    r'(\@\{(?P<operandLabel1>[^}]*)\})|' +
                    r'(\%(?P<operandReg0>\w\w*))|' +
                    r'(\%\{(?P<operandReg1>[^}]*)\})|' +
                    r'(\$(?P<operandImm0>\w\w*))|' +
                    r'(\$\{(?P<operandImm1>[^}]*)\}))')
        lineMatch = lineRe.search(code)
        while lineMatch != None:
            statement = MicroOpStatement()
            # Get a line and seperate it from the rest of the code
            line = lineMatch.group("line")
            orig_line = line
            # print "Parsing line %s" % line
            code = lineRe.sub('', code, 1)

            # Find the label, if any
            labelMatch = labelRe.search(line)
            if labelMatch != None:
                statement.label = labelMatch.group("label")
                # print "Found label %s." % statement.label
            # Clear the label from the statement
            line = labelRe.sub('', line, 1)

            # Find the class name which is roughly equivalent to the op name
            classMatch = classRe.search(line)
            if classMatch == None:
                raise Exception, "Couldn't find class name in statement: %s" \
                        % orig_line
            else:
                statement.className = classMatch.group("className")
                # print "Found class name %s." % statement.className

            # Clear the class name from the statement
            line = classRe.sub('', line, 1)

            #Find as many arguments as you can
            statement.args = []
            opMatch = opRe.search(line)
            while opMatch is not None:
                statement.args.append({})
                # args is a list of dicts which collect different
                # representations of operand values. Different forms might be
                # needed in different places, for instance to replace a label
                # with an offset.
                for opType in ("operandLabel0", "operandReg0", "operandImm0",
                               "operandLabel1", "operandReg1", "operandImm1"):
                    if opMatch.group(opType):
                        statement.args[-1][opType[:-1]] = opMatch.group(opType)
                if len(statement.args[-1]) == 0:
                    print "Problem parsing operand in statement: %s" \
                            % orig_line
                line = opRe.sub('', line, 1)
                # print "Found operand %s." % statement.args[-1]
                opMatch = opRe.search(line)
            # print "Found operands", statement.args

            # Add this statement to our collection
            statements.append(statement)

            # Get the next line
            lineMatch = lineRe.search(code)

        # Decode the labels into displacements

        labels = {}
        micropc = 0
        for statement in statements:
            if statement.label:
                labels[statement.label] = count
            micropc += 1
        micropc = 0
        for statement in statements:
            for arg in statement.args:
                if arg.has_key("operandLabel"):
                    if not labels.has_key(arg["operandLabel"]):
                        raise Exception, "Unrecognized label: %s." % arg["operandLabel"]
                    # This is assuming that intra microcode branches go to
                    # the next micropc + displacement, or
                    # micropc + 1 + displacement.
                    arg["operandImm"] = labels[arg["operandLabel"]] - micropc - 1
            micropc += 1

        # If we can implement this instruction with exactly one microop, just
        # use that directly.
        if len(statements) == 1:
            decode_block = "return %s;" % \
                            statements[0].getAllocator()
            return ('', '', decode_block, '')
        else:
            # Build a macroop to contain the sequence of microops we've
            # been given.
            return genMacroOp(name, Name, statements)
}};
