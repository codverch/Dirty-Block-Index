// -*- mode:c++ -*-

// Copyright (c) 2006 The Regents of The University of Michigan
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer;
// redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution;
// neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Authors: Korey Sewell

////////////////////////////////////////////////////////////////////
//
// The actual MIPS32 ISA decoder
// -----------------------------
// The following instructions are specified in the MIPS32 ISA
// Specification. Decoding closely follows the style specified
// in the MIPS32 ISA specification document starting with Table
// A-2 (document available @ www.mips.com)
//
decode OPCODE_HI default Unknown::unknown() {
    //Table A-2
    0x0: decode OPCODE_LO {
        0x0: decode FUNCTION_HI {
            0x0: decode FUNCTION_LO {
                0x1: decode MOVCI {
                    format BasicOp {
                        0: movf({{ Rd = (getCondCode(FCSR, CC) == 0) ? Rd : Rs; }});
                        1: movt({{ Rd = (getCondCode(FCSR, CC) == 1) ? Rd : Rs; }});
                    }
                }

                format BasicOp {
                    //Table A-3 Note: "Specific encodings of the rd, rs, and
                    //rt fields are used to distinguish SLL, SSNOP, and EHB
                    //functions
                    0x0: decode RS  {
                        0x0: decode RT_RD {
                            0x0: decode SA default Nop::nop(){
                                0x1: WarnUnimpl::ssnop();
                                0x3: WarnUnimpl::ehb();
                            }
                            default: sll({{ Rd = Rt.uw << SA; }});
                        }
                    }

                    0x2: decode RS_SRL {
                        0x0:decode SRL {
                            0: srl({{ Rd = Rt.uw >> SA; }});

                            //Hardcoded assuming 32-bit ISA, probably need parameter here
                            1: rotr({{ Rd = (Rt.uw << (32 - SA)) | (Rt.uw >> SA);}});
                        }
                    }

                    0x3: decode RS {
                        0x0: sra({{
                            uint32_t temp = Rt >> SA;
                            if ( (Rt & 0x80000000) > 0 ) {
                                uint32_t mask = 0x80000000;
                                for(int i=0; i < SA; i++) {
                                    temp |= mask;
                                    mask = mask >> 1;
                                }
                            }
                            Rd = temp;
                        }});
                    }

                    0x4: sllv({{ Rd = Rt.uw << Rs<4:0>; }});

                    0x6: decode SRLV {
                        0: srlv({{ Rd = Rt.uw >> Rs<4:0>; }});

                        //Hardcoded assuming 32-bit ISA, probably need parameter here
                        1: rotrv({{ Rd = (Rt.uw << (32 - Rs<4:0>)) | (Rt.uw >> Rs<4:0>);}});
                    }

                    0x7: srav({{
                        int shift_amt = Rs<4:0>;

                        uint32_t temp = Rt >> shift_amt;

                        if ( (Rt & 0x80000000) > 0 ) {
                                uint32_t mask = 0x80000000;
                                for(int i=0; i < shift_amt; i++) {
                                    temp |= mask;
                                    mask = mask >> 1;
                                }
                            }

                        Rd = temp;
                    }});
                }
            }

            0x1: decode FUNCTION_LO {
                //Table A-3 Note: "Specific encodings of the hint field are
                //used to distinguish JR from JR.HB and JALR from JALR.HB"
                format Jump {
                    0x0: decode HINT {
                        0x1: jr_hb({{ NNPC = Rs & ~1; }}, IsReturn, ClearHazards);
                        default: jr({{ NNPC = Rs & ~1; }}, IsReturn);
                    }

                    0x1: decode HINT {
                        0x1: jalr_hb({{ Rd = NNPC; NNPC = Rs; }}, IsCall, Link
                                     , ClearHazards);
                        default: jalr({{ Rd = NNPC; NNPC = Rs; }}, IsCall,
                                      Link);
                    }
                }

                format BasicOp {
                    0x2: movz({{ Rd = (Rt == 0) ? Rs : Rd; }});
                    0x3: movn({{ Rd = (Rt != 0) ? Rs : Rd; }});
                    0x4: syscall({{ xc->syscall(R2); }},
                                 IsSerializeAfter, IsNonSpeculative);
                    0x7: sync({{ ; }}, IsMemBarrier);
                }

                format FailUnimpl {
                    0x5: break();
                }
            }

            0x2: decode FUNCTION_LO {
                format HiLoMiscOp {
                    0x0: mfhi({{ Rd = HI; }});
                    0x1: mthi({{ HI = Rs; }});
                    0x2: mflo({{ Rd = LO; }});
                    0x3: mtlo({{ LO = Rs; }});
                }
            }

            0x3: decode FUNCTION_LO {
                format HiLoOp {
                    0x0: mult({{ int64_t val = Rs.sd * Rt.sd; }});
                    0x1: multu({{ uint64_t val = Rs.ud * Rt.ud; }});
                    0x2: div({{ int64_t val;
                                if (Rt.sd != 0) {
                                    int64_t hi = Rs.sd % Rt.sd;
                                    int64_t lo = Rs.sd / Rt.sd;
                                    val = (hi << 32) | lo;
                                }
                             }});
                    0x3: divu({{ uint64_t val;
                                 if (Rt.ud != 0) {
                                     uint64_t hi = Rs.ud % Rt.ud;
                                     uint64_t lo = Rs.ud / Rt.ud;
                                     val = (hi << 32) | lo;
                                 }
                              }});
                }
            }

            0x4: decode HINT {
                0x0: decode FUNCTION_LO {
                    format IntOp {
                        0x0: add({{  Rd.sw = Rs.sw + Rt.sw; /*Trap on Overflow*/}});
                        0x1: addu({{ Rd.sw = Rs.sw + Rt.sw;}});
                        0x2: sub({{ Rd.sw = Rs.sw - Rt.sw;  /*Trap on Overflow*/}});
                        0x3: subu({{ Rd.sw = Rs.sw - Rt.sw;}});
                        0x4: and({{ Rd = Rs & Rt;}});
                        0x5: or({{ Rd = Rs | Rt;}});
                        0x6: xor({{ Rd = Rs ^ Rt;}});
                        0x7: nor({{ Rd = ~(Rs | Rt);}});
                    }
                }
            }

            0x5: decode HINT {
                0x0: decode FUNCTION_LO {
                    format IntOp{
                        0x2: slt({{  Rd.sw = ( Rs.sw < Rt.sw ) ? 1 : 0}});
                        0x3: sltu({{ Rd.uw = ( Rs.uw < Rt.uw ) ? 1 : 0}});
                    }
                }
            }

            0x6: decode FUNCTION_LO {
                format Trap {
                    0x0: tge({{  cond = (Rs.sw >= Rt.sw); }});
                    0x1: tgeu({{ cond = (Rs.uw >= Rt.uw); }});
                    0x2: tlt({{ cond = (Rs.sw < Rt.sw); }});
                    0x3: tltu({{ cond = (Rs.uw >= Rt.uw); }});
                    0x4: teq({{ cond = (Rs.sw == Rt.sw); }});
                    0x6: tne({{ cond = (Rs.sw != Rt.sw); }});
                }
            }
        }

        0x1: decode REGIMM_HI {
            0x0: decode REGIMM_LO {
                format Branch {
                    0x0: bltz({{ cond = (Rs.sw < 0); }});
                    0x1: bgez({{ cond = (Rs.sw >= 0); }});
                    0x2: bltzl({{ cond = (Rs.sw < 0); }}, Likely);
                    0x3: bgezl({{ cond = (Rs.sw >= 0); }}, Likely);
                }
            }

            0x1: decode REGIMM_LO {
                format Trap {
                    0x0: tgei( {{ cond = (Rs.sw >= INTIMM); }});
                    0x1: tgeiu({{ cond = (Rs.uw >= INTIMM); }});
                    0x2: tlti( {{ cond = (Rs.sw < INTIMM); }});
                    0x3: tltiu({{ cond = (Rs.uw < INTIMM); }});
                    0x4: teqi( {{ cond = (Rs.sw == INTIMM);}});
                    0x6: tnei( {{ cond = (Rs.sw != INTIMM);}});
                }
            }

            0x2: decode REGIMM_LO {
                format Branch {
                    0x0: bltzal({{ cond = (Rs.sw < 0); }}, Link);
                    0x1: decode RS {
                        0x0: bal ({{ cond = 1; }}, IsCall, Link);
                        default: bgezal({{ cond = (Rs.sw >= 0); }}, Link);
                    }
                    0x2: bltzall({{ cond = (Rs.sw < 0); }}, Link, Likely);
                    0x3: bgezall({{ cond = (Rs.sw >= 0); }}, Link, Likely);
                }
            }

            0x3: decode REGIMM_LO {
                format WarnUnimpl {
                    0x7: synci();
                }
            }
        }

        format Jump {
            0x2: j({{ NNPC = (NPC & 0xF0000000) | (JMPTARG << 2);}});
            0x3: jal({{ NNPC = (NPC & 0xF0000000) | (JMPTARG << 2); }}, IsCall,
                     Link);
        }

        format Branch {
            0x4: decode RS_RT  {
                0x0: b({{ cond = 1; }});
                default: beq({{ cond = (Rs.sw == Rt.sw); }});
            }
            0x5: bne({{ cond = (Rs.sw != Rt.sw); }});
            0x6: blez({{ cond = (Rs.sw <= 0); }});
            0x7: bgtz({{ cond = (Rs.sw > 0); }});
        }
    }

    0x1: decode OPCODE_LO {
        format IntImmOp {
            0x0: addi({{ Rt.sw = Rs.sw + imm; /*Trap If Overflow*/}});
            0x1: addiu({{ Rt.sw = Rs.sw + imm;}});
            0x2: slti({{ Rt.sw = ( Rs.sw < imm) ? 1 : 0 }});
            0x3: sltiu({{ Rt.uw = ( Rs.uw < (uint32_t)sextImm ) ? 1 : 0 }});
            0x4: andi({{ Rt.sw = Rs.sw & zextImm;}});
            0x5: ori({{ Rt.sw = Rs.sw | zextImm;}});
            0x6: xori({{ Rt.sw = Rs.sw ^ zextImm;}});

            0x7: decode RS {
                0x0: lui({{ Rt = imm << 16}});
            }
        }
    }

    0x2: decode OPCODE_LO {
        //Table A-11 MIPS32 COP0 Encoding of rs Field
        0x0: decode RS_MSB {
            0x0: decode RS {
                format CP0Control {
                    0x0: mfc0({{ Rt = xc->readMiscReg(RD << 5 | SEL); }});
                    0x4: mtc0({{ xc->setMiscReg(RD << 5 | SEL, Rt); }});
                }

                format MipsMT {
                    0x8: mftr();
                    0xC: mttr();
                    0xB: decode RD {
                        0x0: decode SC {
                            0x0: dvpe();
                            0x1: evpe();
                        }
                        0x1: decode SC {
                            0x0: dmt();
                            0x1: emt();
                            0xC: decode SC {
                                0x0: di();
                                0x1: ei();
                            }
                        }
                    }
                }

                format FailUnimpl {
                    0xA: rdpgpr();
                    0xE: wrpgpr();
                }
            }

            //Table A-12 MIPS32 COP0 Encoding of Function Field When rs=CO
            0x1: decode FUNCTION {
                format FailUnimpl {
                    0x01: tlbr();
                    0x02: tlbwi();
                    0x06: tlbwr();
                    0x08: tlbp();

                    0x18: eret();
                    0x1F: deret();
                    0x20: wait();
                }
            }
        }

        //Table A-13 MIPS32 COP1 Encoding of rs Field
        0x1: decode RS_MSB {

            0x0: decode RS_HI {
                0x0: decode RS_LO {
                    format CP1Control {
                        0x0: mfc1 ({{ Rt.uw = Fs.uw; }});

                        0x2: cfc1({{
                            switch (FS)
                            {
                              case 0:
                                Rt = FIR;
                                break;
                              case 25:
                                Rt = 0 | (FCSR & 0xFE000000) >> 24 | (FCSR & 0x00800000) >> 23;
                                break;
                              case 26:
                                Rt = 0 | (FCSR & 0x0003F07C);
                                break;
                              case 28:
                                Rt = 0 | (FCSR & 0x00000F80) | (FCSR & 0x01000000) >> 21 | (FCSR & 0x00000003);
                                break;
                              case 31:
                                Rt = FCSR;
                                break;
                              default:
                                panic("FP Control Value (%d) Not Valid");
                            }
                        }});

                        0x3: mfhc1({{ Rt.uw = Fs.ud<63:32>;}});

                        0x4: mtc1 ({{ Fs.uw = Rt.uw;       }});

                        0x6: ctc1({{
                            switch (FS)
                            {
                              case 25:
                                FCSR = 0 | (Rt.uw<7:1> << 25) // move 31...25
                                    | (FCSR & 0x01000000) // bit 24
                                    | (FCSR & 0x004FFFFF);// bit 22...0
                                break;

                              case 26:
                                FCSR = 0 | (FCSR & 0xFFFC0000) // move 31...18
                                    | Rt.uw<17:12> << 12           // bit 17...12
                                    | (FCSR & 0x00000F80) << 7// bit 11...7
                                    | Rt.uw<6:2> << 2              // bit 6...2
                                    | (FCSR & 0x00000002);     // bit 1...0
                                break;

                              case 28:
                                FCSR = 0 | (FCSR & 0xFE000000) // move 31...25
                                    | Rt.uw<2:2> << 24       // bit 24
                                    | (FCSR & 0x00FFF000) << 23// bit 23...12
                                    | Rt.uw<11:7> << 7       // bit 24
                                    | (FCSR & 0x000007E)
                                    | Rt.uw<1:0>;// bit 22...0
                                break;

                              case 31:
                                FCSR  = Rt.uw;
                                break;

                              default:
                                panic("FP Control Value (%d) Not Available. Ignoring Access to"
                                      "Floating Control Status Register", FS);
                            }
                        }});

                        0x7: mthc1({{
                             uint64_t fs_hi = Rt.uw;
                             uint64_t fs_lo = Fs.ud & 0x0FFFFFFFF;
                             Fs.ud = (fs_hi << 32) | fs_lo;
                        }});

                    }
                }

                0x1: decode ND {
                    format Branch {
                        0x0: decode TF {
                            0x0: bc1f({{ cond = getCondCode(FCSR, BRANCH_CC) == 0;
                                      }});
                            0x1: bc1t({{ cond = getCondCode(FCSR, BRANCH_CC) == 1;
                                      }});
                        }
                        0x1: decode TF {
                            0x0: bc1fl({{ cond = getCondCode(FCSR, BRANCH_CC) == 0;
                                       }}, Likely);
                            0x1: bc1tl({{ cond = getCondCode(FCSR, BRANCH_CC) == 1;
                                       }}, Likely);
                        }
                    }
                }
            }

            0x1: decode RS_HI {
                0x2: decode RS_LO {
                    //Table A-14 MIPS32 COP1 Encoding of Function Field When rs=S
                    //(( single-precision floating point))
                    0x0: decode FUNCTION_HI {
                        0x0: decode FUNCTION_LO {
                            format FloatOp {
                                0x0: add_s({{ Fd.sf = Fs.sf + Ft.sf;}});
                                0x1: sub_s({{ Fd.sf = Fs.sf - Ft.sf;}});
                                0x2: mul_s({{ Fd.sf = Fs.sf * Ft.sf;}});
                                0x3: div_s({{ Fd.sf = Fs.sf / Ft.sf;}});
                                0x4: sqrt_s({{ Fd.sf = sqrt(Fs.sf);}});
                                0x5: abs_s({{ Fd.sf = fabs(Fs.sf);}});
                                0x7: neg_s({{ Fd.sf = -Fs.sf;}});
                            }

                            0x6: BasicOp::mov_s({{ Fd.sf = Fs.sf;}});
                        }

                        0x1: decode FUNCTION_LO {
                            format FloatConvertOp {
                                0x0: round_l_s({{ val = Fs.sf; }}, ToLong,
                                               Round);
                                0x1: trunc_l_s({{ val = Fs.sf; }}, ToLong,
                                               Trunc);
                                0x2: ceil_l_s({{ val = Fs.sf; }}, ToLong,
                                               Ceil);
                                0x3: floor_l_s({{ val = Fs.sf; }}, ToLong,
                                               Floor);
                                0x4: round_w_s({{ val = Fs.sf; }}, ToWord,
                                               Round);
                                0x5: trunc_w_s({{ val = Fs.sf; }}, ToWord,
                                               Trunc);
                                0x6: ceil_w_s({{ val = Fs.sf; }}, ToWord,
                                               Ceil);
                                0x7: floor_w_s({{ val = Fs.sf; }}, ToWord,
                                               Floor);
                            }
                        }

                        0x2: decode FUNCTION_LO {
                            0x1: decode MOVCF {
                                format BasicOp {
                                    0x0: movf_s({{ Fd = (getCondCode(FCSR,CC) == 0) ? Fs : Fd; }});
                                    0x1: movt_s({{ Fd = (getCondCode(FCSR,CC) == 1) ? Fs : Fd; }});
                                }
                            }

                            format BasicOp {
                                0x2: movz_s({{ Fd = (Rt == 0) ? Fs : Fd; }});
                                0x3: movn_s({{ Fd = (Rt != 0) ? Fs : Fd; }});
                            }

                            format FloatOp {
                                0x5: recip_s({{ Fd = 1 / Fs; }});
                                0x6: rsqrt_s({{ Fd = 1 / sqrt(Fs);}});
                            }
                        }

                        0x4: decode FUNCTION_LO {
                            format FloatConvertOp {
                                0x1: cvt_d_s({{ val = Fs.sf; }}, ToDouble);
                                0x4: cvt_w_s({{ val = Fs.sf; }}, ToWord);
                                0x5: cvt_l_s({{ val = Fs.sf; }}, ToLong);
                            }

                            0x6: FloatOp::cvt_ps_s({{
                                    Fd.ud = (uint64_t) Fs.uw << 32 |
                                            (uint64_t) Ft.uw;
                                }});
                        }

                        0x6: decode FUNCTION_LO {
                            format FloatCompareOp {
                                0x0: c_f_s({{ cond = 0; }}, SinglePrecision,
                                           UnorderedFalse);
                                0x1: c_un_s({{ cond = 0; }}, SinglePrecision,
                                            UnorderedTrue);
                                0x2: c_eq_s({{ cond = (Fs.sf == Ft.sf); }},
                                            UnorderedFalse);
                                0x3: c_ueq_s({{ cond = (Fs.sf == Ft.sf); }},
                                             UnorderedTrue);
                                0x4: c_olt_s({{ cond = (Fs.sf < Ft.sf);	}},
                                             UnorderedFalse);
                                0x5: c_ult_s({{ cond = (Fs.sf < Ft.sf); }},
                                             UnorderedTrue);
                                0x6: c_ole_s({{ cond = (Fs.sf <= Ft.sf); }},
                                             UnorderedFalse);
                                0x7: c_ule_s({{ cond = (Fs.sf <= Ft.sf); }},
                                             UnorderedTrue);
                            }
                        }

                        0x7: decode FUNCTION_LO {
                            format FloatCompareOp {
                                0x0: c_sf_s({{ cond = 0; }}, SinglePrecision,
                                            UnorderedFalse, QnanException);
                                0x1: c_ngle_s({{ cond = 0; }}, SinglePrecision,
                                              UnorderedTrue, QnanException);
                                0x2: c_seq_s({{ cond = (Fs.sf == Ft.sf);}},
                                             UnorderedFalse, QnanException);
                                0x3: c_ngl_s({{ cond = (Fs.sf == Ft.sf); }},
                                             UnorderedTrue, QnanException);
                                0x4: c_lt_s({{ cond = (Fs.sf < Ft.sf); }},
                                            UnorderedFalse, QnanException);
                                0x5: c_nge_s({{ cond = (Fs.sf < Ft.sf); }},
                                             UnorderedTrue, QnanException);
                                0x6: c_le_s({{ cond = (Fs.sf <= Ft.sf); }},
                                            UnorderedFalse, QnanException);
                                0x7: c_ngt_s({{ cond = (Fs.sf <= Ft.sf); }},
                                             UnorderedTrue, QnanException);
                            }
                        }
                    }

                    //Table A-15 MIPS32 COP1 Encoding of Function Field When rs=D
                    0x1: decode FUNCTION_HI {
                        0x0: decode FUNCTION_LO {
                            format FloatOp {
                                0x0: add_d({{ Fd.df = Fs.df + Ft.df; }});
                                0x1: sub_d({{ Fd.df = Fs.df - Ft.df; }});
                                0x2: mul_d({{ Fd.df = Fs.df * Ft.df; }});
                                0x3: div_d({{ Fd.df = Fs.df / Ft.df; }});
                                0x4: sqrt_d({{ Fd.df = sqrt(Fs.df);  }});
                                0x5: abs_d({{ Fd.df = fabs(Fs.df);   }});
                                0x7: neg_d({{ Fd.df = -1 * Fs.df;    }});
                            }

                            0x6: BasicOp::mov_d({{ Fd.df = Fs.df;    }});
                        }

                        0x1: decode FUNCTION_LO {
                            format FloatConvertOp {
                                0x0: round_l_d({{ val = Fs.df; }}, ToLong,
                                               Round);
                                0x1: trunc_l_d({{ val = Fs.df; }}, ToLong,
                                               Trunc);
                                0x2: ceil_l_d({{ val = Fs.df; }}, ToLong,
                                               Ceil);
                                0x3: floor_l_d({{ val = Fs.df; }}, ToLong,
                                               Floor);
                                0x4: round_w_d({{ val = Fs.df; }}, ToWord,
                                               Round);
                                0x5: trunc_w_d({{ val = Fs.df; }}, ToWord,
                                               Trunc);
                                0x6: ceil_w_d({{ val = Fs.df; }}, ToWord,
                                               Ceil);
                                0x7: floor_w_d({{ val = Fs.df; }}, ToWord,
                                               Floor);
                            }
                        }

                        0x2: decode FUNCTION_LO {
                            0x1: decode MOVCF {
                                format BasicOp {
                                    0x0: movf_d({{ Fd.df = (getCondCode(FCSR,CC) == 0) ?
                                                       Fs.df : Fd.df;
                                                }});
                                    0x1: movt_d({{ Fd.df = (getCondCode(FCSR,CC) == 1) ?
                                                       Fs.df : Fd.df;
                                                }});
                                }
                            }

                            format BasicOp {
                                0x2: movz_d({{ Fd.df = (Rt == 0) ? Fs.df : Fd.df; }});
                                0x3: movn_d({{ Fd.df = (Rt != 0) ? Fs.df : Fd.df; }});
                            }

                            format FloatOp {
                                0x5: recip_d({{ Fd.df = 1 / Fs.df }});
                                0x6: rsqrt_d({{ Fd.df = 1 / sqrt(Fs.df) }});
                            }
                        }

                        0x4: decode FUNCTION_LO {
                            format FloatConvertOp {
                                0x0: cvt_s_d({{ val = Fs.df; }}, ToSingle);
                                0x4: cvt_w_d({{ val = Fs.df; }}, ToWord);
                                0x5: cvt_l_d({{ val = Fs.df; }}, ToLong);
                            }
                        }

                        0x6: decode FUNCTION_LO {
                            format FloatCompareOp {
                                0x0: c_f_d({{ cond = 0; }}, DoublePrecision,
                                           UnorderedFalse);
                                0x1: c_un_d({{ cond = 0; }}, DoublePrecision,
                                            UnorderedTrue);
                                0x2: c_eq_d({{ cond = (Fs.df == Ft.df); }},
                                            UnorderedFalse);
                                0x3: c_ueq_d({{ cond = (Fs.df == Ft.df); }},
                                             UnorderedTrue);
                                0x4: c_olt_d({{ cond = (Fs.df < Ft.df);	}},
                                             UnorderedFalse);
                                0x5: c_ult_d({{ cond = (Fs.df < Ft.df); }},
                                             UnorderedTrue);
                                0x6: c_ole_d({{ cond = (Fs.df <= Ft.df); }},
                                             UnorderedFalse);
                                0x7: c_ule_d({{ cond = (Fs.df <= Ft.df); }},
                                             UnorderedTrue);
                            }
                        }

                        0x7: decode FUNCTION_LO {
                            format FloatCompareOp {
                                0x0: c_sf_d({{ cond = 0; }}, DoublePrecision,
                                            UnorderedFalse, QnanException);
                                0x1: c_ngle_d({{ cond = 0; }}, DoublePrecision,
                                              UnorderedTrue, QnanException);
                                0x2: c_seq_d({{ cond = (Fs.df == Ft.df); }},
                                             UnorderedFalse, QnanException);
                                0x3: c_ngl_d({{ cond = (Fs.df == Ft.df); }},
                                             UnorderedTrue, QnanException);
                                0x4: c_lt_d({{ cond = (Fs.df < Ft.df); }},
                                            UnorderedFalse, QnanException);
                                0x5: c_nge_d({{ cond = (Fs.df < Ft.df); }},
                                             UnorderedTrue, QnanException);
                                0x6: c_le_d({{ cond = (Fs.df <= Ft.df); }},
                                            UnorderedFalse, QnanException);
                                0x7: c_ngt_d({{ cond = (Fs.df <= Ft.df); }},
                                             UnorderedTrue, QnanException);
                            }
                        }
                    }

                    //Table A-16 MIPS32 COP1 Encoding of Function Field When rs=W
                    0x4: decode FUNCTION {
                        format FloatConvertOp {
                            0x20: cvt_s_w({{ val = Fs.uw; }}, ToSingle);
                            0x21: cvt_d_w({{ val = Fs.uw; }}, ToDouble);
                            0x26: FailUnimpl::cvt_ps_w();
                        }
                    }

                    //Table A-16 MIPS32 COP1 Encoding of Function Field When rs=L1
                    //Note: "1. Format type L is legal only if 64-bit floating point operations
                    //are enabled."
                    0x5: decode FUNCTION_HI {
                        format FloatConvertOp {
                            0x20: cvt_s_l({{ val = Fs.ud; }}, ToSingle);
                            0x21: cvt_d_l({{ val = Fs.ud; }}, ToDouble);
                            0x26: FailUnimpl::cvt_ps_l();
                        }
                    }

                    //Table A-17 MIPS64 COP1 Encoding of Function Field When rs=PS1
                    //Note: "1. Format type PS is legal only if 64-bit floating point operations
                    //are enabled. "
                    0x6: decode FUNCTION_HI {
                        0x0: decode FUNCTION_LO {
                            format Float64Op {
                                0x0: add_ps({{
                                    Fd1.sf = Fs1.sf + Ft2.sf;
                                    Fd2.sf = Fs2.sf + Ft2.sf;
                                }});
                                0x1: sub_ps({{
                                    Fd1.sf = Fs1.sf - Ft2.sf;
                                    Fd2.sf = Fs2.sf - Ft2.sf;
                                }});
                                0x2: mul_ps({{
                                    Fd1.sf = Fs1.sf * Ft2.sf;
                                    Fd2.sf = Fs2.sf * Ft2.sf;
                                }});
                                0x5: abs_ps({{
                                    Fd1.sf = fabs(Fs1.sf);
                                    Fd2.sf = fabs(Fs2.sf);
                                }});
                                0x6: mov_ps({{
                                    Fd1.sf = Fs1.sf;
                                    Fd2.sf = Fs2.sf;
                                }});
                                0x7: neg_ps({{
                                    Fd1.sf = -(Fs1.sf);
                                    Fd2.sf = -(Fs2.sf);
                                }});
                            }
                        }

                        0x2: decode FUNCTION_LO {
                            0x1: decode MOVCF {
                                format Float64Op {
                                    0x0: movf_ps({{
                                        Fd1 = (getCondCode(FCSR, CC) == 0) ?
                                            Fs1 : Fd1;
                                        Fd2 = (getCondCode(FCSR, CC+1) == 0) ?
                                            Fs2 : Fd2;
                                    }});
                                    0x1: movt_ps({{
                                        Fd2 = (getCondCode(FCSR, CC) == 1) ?
                                            Fs1 : Fd1;
                                        Fd2 = (getCondCode(FCSR, CC+1) == 1) ?
                                            Fs2 : Fd2;
                                    }});
                                }
                            }

                            format Float64Op {
                                0x2: movz_ps({{
                                    Fd1 = (getCondCode(FCSR, CC) == 0) ?
                                        Fs1 : Fd1;
                                    Fd2 = (getCondCode(FCSR, CC) == 0) ?
                                        Fs2 : Fd2;
                                }});
                                0x3: movn_ps({{
                                    Fd1 = (getCondCode(FCSR, CC) == 1) ?
                                        Fs1 : Fd1;
                                    Fd2 = (getCondCode(FCSR, CC) == 1) ?
                                        Fs2 : Fd2;
                                }});
                            }

                        }

                        0x4: decode FUNCTION_LO {
                            0x0: FloatOp::cvt_s_pu({{ Fd.sf = Fs2.sf; }});
                        }

                        0x5: decode FUNCTION_LO {
                            0x0: FloatOp::cvt_s_pl({{ Fd.sf = Fs1.sf; }});

                            format Float64Op {
                                0x4: pll({{ Fd.ud = (uint64_t) Fs1.uw << 32 |
                                                    Ft1.uw;
                                         }});
                                0x5: plu({{ Fd.ud = (uint64_t) Fs1.uw << 32 |
                                                    Ft2.uw;
                                         }});
                                0x6: pul({{ Fd.ud = (uint64_t) Fs2.uw << 32 |
                                                    Ft1.uw;
                                         }});
                                0x7: puu({{ Fd.ud = (uint64_t) Fs2.uw << 32 |
                                                    Ft2.uw;
                                         }});
                            }
                        }

                        0x6: decode FUNCTION_LO {
                            format FloatPSCompareOp {
                                0x0: c_f_ps({{ cond1 = 0; }}, {{ cond2 = 0; }},
                                            UnorderedFalse);
                                0x1: c_un_ps({{ cond1 = 0; }}, {{ cond2 = 0; }},
                                             UnorderedTrue);
                                0x2: c_eq_ps({{ cond1 = (Fs1.sf == Ft1.sf); }},
                                             {{ cond2 = (Fs2.sf == Ft2.sf); }},
                                             UnorderedFalse);
                                0x3: c_ueq_ps({{ cond1 = (Fs1.sf == Ft1.sf); }},
                                              {{ cond2 = (Fs2.sf == Ft2.sf); }},
                                              UnorderedTrue);
                                0x4: c_olt_ps({{ cond1 = (Fs1.sf < Ft1.sf); }},
                                              {{ cond2 = (Fs2.sf < Ft2.sf); }},
                                              UnorderedFalse);
                                0x5: c_ult_ps({{ cond1 = (Fs.sf < Ft.sf); }},
                                              {{ cond2 = (Fs2.sf < Ft2.sf); }},
                                              UnorderedTrue);
                                0x6: c_ole_ps({{ cond1 = (Fs.sf <= Ft.sf); }},
                                              {{ cond2 = (Fs2.sf <= Ft2.sf); }},
                                              UnorderedFalse);
                                0x7: c_ule_ps({{ cond1 = (Fs1.sf <= Ft1.sf); }},
                                              {{ cond2 = (Fs2.sf <= Ft2.sf); }},
                                              UnorderedTrue);
                            }
                        }

                        0x7: decode FUNCTION_LO {
                            format FloatPSCompareOp {
                                0x0: c_sf_ps({{ cond1 = 0; }}, {{ cond2 = 0; }},
                                             UnorderedFalse, QnanException);
                                0x1: c_ngle_ps({{ cond1 = 0; }},
                                               {{ cond2 = 0; }},
                                               UnorderedTrue, QnanException);
                                0x2: c_seq_ps({{ cond1 = (Fs1.sf == Ft1.sf); }},
                                              {{ cond2 = (Fs2.sf == Ft2.sf); }},
                                              UnorderedFalse, QnanException);
                                0x3: c_ngl_ps({{ cond1 = (Fs1.sf == Ft1.sf); }},
                                              {{ cond2 = (Fs2.sf == Ft2.sf); }},
                                              UnorderedTrue, QnanException);
                                0x4: c_lt_ps({{ cond1 = (Fs1.sf < Ft1.sf); }},
                                             {{ cond2 = (Fs2.sf < Ft2.sf); }},
                                             UnorderedFalse, QnanException);
                                0x5: c_nge_ps({{ cond1 = (Fs1.sf < Ft1.sf); }},
                                              {{ cond2 = (Fs2.sf < Ft2.sf); }},
                                              UnorderedTrue, QnanException);
                                0x6: c_le_ps({{ cond1 = (Fs1.sf <= Ft1.sf); }},
                                             {{ cond2 = (Fs2.sf <= Ft2.sf); }},
                                             UnorderedFalse, QnanException);
                                0x7: c_ngt_ps({{ cond1 = (Fs1.sf <= Ft1.sf); }},
                                              {{ cond2 = (Fs2.sf <= Ft2.sf); }},
                                              UnorderedTrue, QnanException);
                            }
                        }
                    }
                }
            }
        }

        //Table A-19 MIPS32 COP2 Encoding of rs Field
        0x2: decode RS_MSB {
            format FailUnimpl {
                0x0: decode RS_HI {
                    0x0: decode RS_LO {
                        0x0: mfc2();
                        0x2: cfc2();
                        0x3: mfhc2();
                        0x4: mtc2();
                        0x6: ctc2();
                        0x7: mftc2();
                    }

                    0x1: decode ND {
                        0x0: decode TF {
                            0x0: bc2f();
                            0x1: bc2t();
                        }

                        0x1: decode TF {
                            0x0: bc2fl();
                            0x1: bc2tl();
                        }
                    }
                }
            }
        }

        //Table A-20 MIPS64 COP1X Encoding of Function Field 1
        //Note: "COP1X instructions are legal only if 64-bit floating point
        //operations are enabled."
        0x3: decode FUNCTION_HI {
            0x0: decode FUNCTION_LO {
                format LoadIndexedMemory {
                    0x0: lwxc1({{ Fd.uw = Mem.uw;}});
                    0x1: ldxc1({{ Fd.ud = Mem.ud;}});
                    0x5: luxc1({{ Fd.ud = Mem.ud;}},
                               {{ EA = (Rs + Rt) & ~7; }});
                }
            }

            0x1: decode FUNCTION_LO {
                format StoreIndexedMemory {
                    0x0: swxc1({{ Mem.uw = Fs.uw;}});
                    0x1: sdxc1({{ Mem.ud = Fs.ud;}});
                    0x5: suxc1({{ Mem.ud = Fs.ud;}},
                               {{ EA = (Rs + Rt) & ~7; }});
                }

                0x7: Prefetch::prefx({{ EA = Rs + Rt; }});
            }

            0x3: decode FUNCTION_LO {
                0x6: Float64Op::alnv_ps({{ if (Rs<2:0> == 0) {
                                               Fd.ud = Fs.ud;
                                           } else if (Rs<2:0> == 4) {
                                             #if BYTE_ORDER == BIG_ENDIAN
                                               Fd.ud = Fs.ud<31:0> << 32 |
                                                       Ft.ud<63:32>;
                                             #elif BYTE_ORDER == LITTLE_ENDIAN
                                               Fd.ud = Ft.ud<31:0> << 32 |
                                                       Fs.ud<63:32>;
                                             #endif
                                           } else {
                                               Fd.ud = Fd.ud;
                                           }
                                        }});
            }

            format FloatAccOp {
                0x4: decode FUNCTION_LO {
                    0x0: madd_s({{ Fd.sf = (Fs.sf * Ft.sf) + Fr.sf; }});
                    0x1: madd_d({{ Fd.df = (Fs.df * Ft.df) + Fr.df; }});
                    0x6: madd_ps({{
                        Fd1.sf = (Fs1.df * Ft1.df) + Fr1.df;
                        Fd2.sf = (Fs2.df * Ft2.df) + Fr2.df;
                    }});
                }

                0x5: decode FUNCTION_LO {
                    0x0: msub_s({{ Fd.sf = (Fs.sf * Ft.sf) - Fr.sf; }});
                    0x1: msub_d({{ Fd.df = (Fs.df * Ft.df) - Fr.df; }});
                    0x6: msub_ps({{
                        Fd1.sf = (Fs1.df * Ft1.df) - Fr1.df;
                        Fd2.sf = (Fs2.df * Ft2.df) - Fr2.df;
                    }});
                }

                0x6: decode FUNCTION_LO {
                    0x0: nmadd_s({{ Fd.sf = (-1 * Fs.sf * Ft.sf) - Fr.sf; }});
                    0x1: nmadd_d({{ Fd.df = (-1 * Fs.df * Ft.df) + Fr.df; }});
                    0x6: nmadd_ps({{
                        Fd1.sf = -((Fs1.df * Ft1.df) + Fr1.df);
                        Fd2.sf = -((Fs2.df * Ft2.df) + Fr2.df);
                    }});
                }

                0x7: decode FUNCTION_LO {
                    0x0: nmsub_s({{ Fd.sf = (-1 * Fs.sf * Ft.sf) - Fr.sf; }});
                    0x1: nmsub_d({{ Fd.df = (-1 * Fs.df * Ft.df) - Fr.df; }});
                    0x6: nmsub_ps({{
                        Fd1.sf = -((Fs1.df * Ft1.df) - Fr1.df);
                        Fd2.sf = -((Fs2.df * Ft2.df) - Fr2.df);
                    }});
                }

            }
        }

        format Branch {
            0x4: beql({{ cond = (Rs.sw == Rt.sw); }}, Likely);
            0x5: bnel({{ cond = (Rs.sw != Rt.sw); }}, Likely);
            0x6: blezl({{ cond = (Rs.sw <= 0); }}, Likely);
            0x7: bgtzl({{ cond = (Rs.sw > 0); }}, Likely);
        }
    }

    0x3: decode OPCODE_LO {
        //Table A-5 MIPS32 SPECIAL2 Encoding of Function Field
        0x4: decode FUNCTION_HI {
            0x0: decode FUNCTION_LO {
                0x2: IntOp::mul({{ int64_t temp1 = Rs.sd * Rt.sd;
                                   Rd.sw = temp1<31:0>
                                }});

                format HiLoOp {
                    0x0: madd({{ int64_t val = ((int64_t) HI << 32 | LO) +
                                          (Rs.sd * Rt.sd);
                              }});
                    0x1: maddu({{ uint64_t val = ((uint64_t) HI << 32 | LO) +
                                           (Rs.ud * Rt.ud);
                               }});
                    0x4: msub({{ int64_t val = ((int64_t) HI << 32 | LO) -
                                          (Rs.sd * Rt.sd);
                              }});
                    0x5: msubu({{ uint64_t val = ((uint64_t) HI << 32 | LO) -
                                           (Rs.ud * Rt.ud);
                               }});
                }
            }

            0x4: decode FUNCTION_LO {
                format BasicOp {
                    0x0: clz({{ int cnt = 32;
                                for (int idx = 31; idx >= 0; idx--) {
                                    if( Rs<idx:idx> == 1) {
                                        cnt = 31 - idx;
                                        break;
                                    }
                                }
                                Rd.uw = cnt;
                             }});
                    0x1: clo({{ int cnt = 32;
                                for (int idx = 31; idx >= 0; idx--) {
                                    if( Rs<idx:idx> == 0) {
                                        cnt = 31 - idx;
                                        break;
                                    }
                                }
                                Rd.uw = cnt;
                             }});
                }
            }

            0x7: decode FUNCTION_LO {
                0x7: FailUnimpl::sdbbp();
            }
        }

        //Table A-6 MIPS32 SPECIAL3 Encoding of Function Field for Release 2
        //of the Architecture
        0x7: decode FUNCTION_HI {
            0x0: decode FUNCTION_LO {
                format BasicOp {
                    0x0: ext({{ Rt.uw = bits(Rs.uw, MSB+LSB, LSB); }});
                    0x4: ins({{ Rt.uw = bits(Rt.uw, 31, MSB+1) << (MSB+1) |
                                        bits(Rs.uw, MSB-LSB, 0) << LSB |
                                        bits(Rt.uw, LSB-1, 0);
                             }});
                }
            }

            0x1: decode FUNCTION_LO {
                format MipsMT {
                    0x0: fork();
                    0x1: yield();
                }
            }

            //Table A-10 MIPS32 BSHFL Encoding of sa Field
            0x4: decode SA {
                format BasicOp {
                    0x02: wsbh({{ Rd.uw = Rt.uw<23:16> << 24 |
                                          Rt.uw<31:24> << 16 |
                                          Rt.uw<7:0>   << 8  |
                                          Rt.uw<15:8>;
                    }});
                    0x10: seb({{ Rd.sw = Rt.sb; }});
                    0x18: seh({{ Rd.sw = Rt.sh; }});
                }
            }

            0x6: decode FUNCTION_LO {
                0x7: FailUnimpl::rdhwr();
            }
        }
    }

    0x4: decode OPCODE_LO {
        format LoadMemory {
            0x0: lb({{ Rt.sw = Mem.sb; }});
            0x1: lh({{ Rt.sw = Mem.sh; }});
            0x3: lw({{ Rt.sw = Mem.sw; }});
            0x4: lbu({{ Rt.uw = Mem.ub; }});
            0x5: lhu({{ Rt.uw = Mem.uh; }});
        }

        format LoadUnalignedMemory {
            0x2: lwl({{ uint32_t mem_shift = 24 - (8 * byte_offset);
                        Rt.uw = mem_word << mem_shift |
                                Rt.uw & mask(mem_shift);
                     }});
            0x6: lwr({{ uint32_t mem_shift = 8 * byte_offset;
                        Rt.uw = Rt.uw & (mask(mem_shift) << (32 - mem_shift)) |
                                mem_word >> mem_shift;
                     }});
        }
    }

    0x5: decode OPCODE_LO {
        format StoreMemory {
            0x0: sb({{ Mem.ub = Rt<7:0>; }});
            0x1: sh({{ Mem.uh = Rt<15:0>; }});
            0x3: sw({{ Mem.uw = Rt<31:0>; }});
        }

        format StoreUnalignedMemory {
            0x2: swl({{ uint32_t reg_shift = 24 - (8 * byte_offset);
                        uint32_t mem_shift = 32 - reg_shift;
                        mem_word = mem_word & (mask(reg_shift) << mem_shift) |
                                   Rt.uw >> reg_shift;
                     }});
            0x6: swr({{ uint32_t reg_shift = 8 * byte_offset;
                        mem_word = Rt.uw << reg_shift |
                                   mem_word & (mask(reg_shift));
                     }});
        }

        0x7: FailUnimpl::cache();
    }

    0x6: decode OPCODE_LO {
        format LoadMemory {
            0x0: ll({{ Rt.uw = Mem.uw; }}, mem_flags=LOCKED);
            0x1: lwc1({{ Ft.uw = Mem.uw; }});
            0x5: ldc1({{ Ft.ud = Mem.ud; }});
        }

        0x3: Prefetch::pref();
    }


    0x7: decode OPCODE_LO {
        0x0: StoreCond::sc({{ Mem.uw = Rt.uw;}},
                           {{ uint64_t tmp = write_result;
                              Rt.uw = (tmp == 0 || tmp == 1) ? tmp : Rt.uw;
                           }}, mem_flags=LOCKED, inst_flags = IsStoreConditional);

        format StoreMemory {
            0x1: swc1({{ Mem.uw = Ft.uw; }});
            0x5: sdc1({{ Mem.ud = Ft.ud; }});
        }
    }
}


