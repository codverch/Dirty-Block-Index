////////////////////////////////////////////////////////////////////
//
// Integer operate instructions
//

output header {{
        /**
         * Base class for integer operations.
         */
        class IntOp : public SparcStaticInst
        {
          protected:
            // Constructor
            IntOp(const char *mnem, ExtMachInst _machInst,
                    OpClass __opClass) :
                SparcStaticInst(mnem, _machInst, __opClass)
            {
            }

            std::string generateDisassembly(Addr pc,
                const SymbolTable *symtab) const;

            virtual bool printPseudoOps(std::ostream &os, Addr pc,
                    const SymbolTable *symtab) const;
        };

        /**
         * Base class for immediate integer operations.
         */
        class IntOpImm : public IntOp
        {
          protected:
            // Constructor
            IntOpImm(const char *mnem, ExtMachInst _machInst,
                    OpClass __opClass) :
                IntOp(mnem, _machInst, __opClass)
            {
            }

            int32_t imm;

            std::string generateDisassembly(Addr pc,
                const SymbolTable *symtab) const;

            virtual bool printPseudoOps(std::ostream &os, Addr pc,
                    const SymbolTable *symtab) const;
        };

        /**
         * Base class for 10 bit immediate integer operations.
         */
        class IntOpImm10 : public IntOpImm
        {
          protected:
            // Constructor
            IntOpImm10(const char *mnem, ExtMachInst _machInst,
                    OpClass __opClass) :
                IntOpImm(mnem, _machInst, __opClass)
            {
                imm = sign_ext(SIMM10, 10);
            }
        };

        /**
         * Base class for 13 bit immediate integer operations.
         */
        class IntOpImm13 : public IntOpImm
        {
          protected:
            // Constructor
            IntOpImm13(const char *mnem, ExtMachInst _machInst,
                    OpClass __opClass) :
                IntOpImm(mnem, _machInst, __opClass)
            {
                imm = sign_ext(SIMM13, 13);
            }
        };

        /**
         * Base class for sethi.
         */
        class SetHi : public IntOpImm
        {
          protected:
            // Constructor
            SetHi(const char *mnem, ExtMachInst _machInst,
                    OpClass __opClass) :
                IntOpImm(mnem, _machInst, __opClass)
            {
                imm = (IMM22 << 10) & 0xFFFFFC00;
            }

            std::string generateDisassembly(Addr pc,
                const SymbolTable *symtab) const;
        };
}};

def template SetHiDecode {{
    {
        if(RD == 0 && IMM22 == 0)
            return (SparcStaticInst *)(new Nop("nop", machInst, No_OpClass));
        else
            return (SparcStaticInst *)(new %(class_name)s(machInst));
    }
}};

output decoder {{

        bool IntOp::printPseudoOps(std::ostream &os, Addr pc,
                const SymbolTable *symbab) const
        {
            if(!strcmp(mnemonic, "or") && _srcRegIdx[0] == 0)
            {
                printMnemonic(os, "mov");
                if(_numSrcRegs > 0)
                    printReg(os, _srcRegIdx[1]);
                ccprintf(os, ", ");
                if(_numDestRegs > 0)
                    printReg(os, _destRegIdx[0]);

                return true;
            }
            return false;
        }

        bool IntOpImm::printPseudoOps(std::ostream &os, Addr pc,
                const SymbolTable *symbab) const
        {
            if(!strcmp(mnemonic, "or"))
            {
                if(_srcRegIdx[0] == 0)
                {
                    if(imm == 0)
                    {
                        printMnemonic(os, "clr");
                        if(_numDestRegs > 0)
                            printReg(os, _destRegIdx[0]);
                        return true;
                    }
                    else
                    {
                        printMnemonic(os, "mov");
                        ccprintf(os, ", 0x%x, ", imm);
                        if(_numDestRegs > 0)
                            printReg(os, _destRegIdx[0]);
                        return true;
                    }
                }
                else if(imm == 0)
                {
                    printMnemonic(os, "mov");
                    if(_numSrcRegs > 0)
                        printReg(os, _srcRegIdx[0]);
                    ccprintf(os, ", ");
                    if(_numDestRegs > 0)
                        printReg(os, _destRegIdx[0]);
                    return true;
                }
            }
            return false;
        }

        std::string IntOp::generateDisassembly(Addr pc,
                const SymbolTable *symtab) const
        {
            std::stringstream response;

            if(!printPseudoOps(response, pc, symtab))
            {
                printMnemonic(response, mnemonic);
                if (_numSrcRegs > 0)
                {
                    printReg(response, _srcRegIdx[0]);
                    for(int x = 1; x < _numSrcRegs; x++)
                    {
                        response << ", ";
                        printReg(response, _srcRegIdx[x]);
                    }
                }
                if (_numDestRegs > 0)
                {
                    if(_numSrcRegs > 0)
                        response << ", ";
                    printReg(response, _destRegIdx[0]);
                }
            }
            return response.str();
        }

        std::string IntOpImm::generateDisassembly(Addr pc,
                const SymbolTable *symtab) const
        {
            std::stringstream response;

            if(!printPseudoOps(response, pc, symtab))
            {
                printMnemonic(response, mnemonic);
                if (_numSrcRegs > 0)
                {
                    printReg(response, _srcRegIdx[0]);
                    for(int x = 1; x < _numSrcRegs - 1; x++)
                    {
                        response << ", ";
                        printReg(response, _srcRegIdx[x]);
                    }
                }
                if(_numSrcRegs > 0)
                    response << ", ";
                ccprintf(response, "0x%x", imm);
                if (_numDestRegs > 0)
                {
                    response << ", ";
                    printReg(response, _destRegIdx[0]);
                }
            }
            return response.str();
        }

        std::string SetHi::generateDisassembly(Addr pc,
                const SymbolTable *symtab) const
        {
            std::stringstream response;

            printMnemonic(response, mnemonic);
            if(_numSrcRegs > 0)
                response << ", ";
            ccprintf(response, "%%hi(0x%x), ", imm);
            printReg(response, _destRegIdx[0]);
            return response.str();
        }
}};

def template IntOpExecute {{
        Fault %(class_name)s::execute(%(CPU_exec_context)s *xc,
                Trace::InstRecord *traceData) const
        {
            Fault fault = NoFault;

            %(op_decl)s;
            %(op_rd)s;
            %(code)s;

            //Write the resulting state to the execution context
            if(fault == NoFault)
            {
                %(cc_code)s;
                %(op_wb)s;
            }
            return fault;
        }
}};

let {{
    def doIntFormat(code, ccCode, name, Name, opt_flags):
        (usesImm, code, immCode,
         rString, iString) = splitOutImm(code)
        iop = InstObjParams(name, Name,	'IntOp', code,
                opt_flags, ("cc_code", ccCode))
        header_output = BasicDeclare.subst(iop)
        decoder_output = BasicConstructor.subst(iop)
        exec_output = IntOpExecute.subst(iop)
        if usesImm:
            imm_iop = InstObjParams(name, Name + 'Imm', 'IntOpImm' + iString,
                    immCode, opt_flags, ("cc_code", ccCode))
            header_output += BasicDeclare.subst(imm_iop)
            decoder_output += BasicConstructor.subst(imm_iop)
            exec_output += IntOpExecute.subst(imm_iop)
            decode_block = ROrImmDecode.subst(iop)
        else:
            decode_block = BasicDecode.subst(iop)
        return (header_output, decoder_output, exec_output, decode_block)

    calcCcCode = '''
        CcrIccN = (Rd >> 63) & 1;
        CcrIccZ = (Rd == 0);
        CcrXccN = (Rd >> 31) & 1;
        CcrXccZ = ((Rd & 0xFFFFFFFF) == 0);
        CcrIccV = %(ivValue)s;
        CcrIccC = %(icValue)s;
        CcrXccV = %(xvValue)s;
        CcrXccC = %(xcValue)s;
        '''
}};

// Primary format for integer operate instructions:
def format IntOp(code, *opt_flags) {{
    ccCode = ''
    (header_output,
     decoder_output,
     exec_output,
     decode_block) = doIntFormat(code, ccCode,
                                 name, Name, opt_flags)
}};

// Primary format for integer operate instructions:
def format IntOpCc(code, icValue, ivValue, xcValue, xvValue, *opt_flags) {{
    ccCode = calcCcCode % vars()
    (header_output,
     decoder_output,
     exec_output,
     decode_block) = doIntFormat(code, ccCode,
                                 name, Name, opt_flags)
}};

// Primary format for integer operate instructions:
def format IntOpCcRes(code, *opt_flags) {{
    ccCode = calcCcCode % {"icValue":"0",
                        "ivValue":"0",
                        "xcValue":"0",
                        "xvValue":"0"}
    (header_output,
     decoder_output,
     exec_output,
     decode_block) = doIntFormat(code, ccCode,
                                 name, Name, opt_flags)
}};

def format SetHi(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'SetHi',
            code, opt_flags, ("cc_code", ''))
    header_output = BasicDeclare.subst(iop)
    decoder_output = BasicConstructor.subst(iop)
    exec_output = IntOpExecute.subst(iop)
    decode_block = SetHiDecode.subst(iop)
}};

