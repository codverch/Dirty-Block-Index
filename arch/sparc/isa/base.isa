////////////////////////////////////////////////////////////////////
//
// Base class for sparc instructions, and some support functions
//

output header {{

        union CondCodes
        {
            struct
            {
                uint8_t c:1;
                uint8_t v:1;
                uint8_t z:1;
                uint8_t n:1;
            };
            uint32_t bits;
        };

        enum CondTest
        {
            Always=0x8,
            Never=0x0,
            NotEqual=0x9,
            Equal=0x1,
            Greater=0xA,
            LessOrEqual=0x2,
            GreaterOrEqual=0xB,
            Less=0x3,
            GreaterUnsigned=0xC,
            LessOrEqualUnsigned=0x4,
            CarryClear=0xD,
            CarrySet=0x5,
            Positive=0xE,
            Negative=0x6,
            OverflowClear=0xF,
            OverflowSet=0x7
        };

        /**
         * Base class for all SPARC static instructions.
         */
        class SparcStaticInst : public StaticInst
        {
          protected:
            // Constructor.
            SparcStaticInst(const char *mnem,
                 MachInst _machInst, OpClass __opClass)
                    : StaticInst(mnem, _machInst, __opClass)
                {
                }

            std::string generateDisassembly(Addr pc,
                const SymbolTable *symtab) const;

            void printReg(std::ostream &os, int reg) const;
        };

        bool passesCondition(uint32_t codes, uint32_t condition);

        inline int64_t sign_ext(uint64_t data, int origWidth)
        {
            int shiftAmount = sizeof(uint64_t) - origWidth;
            return (((int64_t)data) << shiftAmount) >> shiftAmount;
        }
}};

def template ROrImmDecode {{
    {
        return (I ? (SparcStaticInst *)(new %(class_name)sImm(machInst))
                  : (SparcStaticInst *)(new %(class_name)s(machInst)));
    }
}};

let {{
    def splitOutImm(code):
        matcher = re.compile(r'Rs(?P<rNum>\d)_or_imm(?P<iNum>\d+)')
        rOrImmMatch = matcher.search(code)
        if (rOrImmMatch == None):
            return (False, code, '', '', '')
        rString = rOrImmMatch.group("rNum")
        iString = rOrImmMatch.group("iNum")
        orig_code = code
        code = matcher.sub('Rs' + rOrImmMatch.group("rNum"), orig_code)
        imm_code = matcher.sub('imm', orig_code)
        return (True, code, imm_code, rString, iString)

    def genCompositeIop(code, name, Name, parent, opt_flags, **extras):
        origBlock = CodeBlock(code)
        composite = code
        for snippet in extras.values():
            composite += ('\n' + snippet)
        compositeBlock = CodeBlock(composite)
        iop = InstObjParams(name, Name, parent, compositeBlock, opt_flags)
        iop.code = origBlock.code
        iop.orig_code = origBlock.orig_code
        for (name, snippet) in extras.items():
            exec "iop.%s = CodeBlock(snippet).code" % name
        return iop
}};

output decoder {{

        inline void printMnemonic(std::ostream &os, const char * mnemonic)
        {
            ccprintf(os, "\t%s   ", mnemonic);
        }

        void
        SparcStaticInst::printReg(std::ostream &os, int reg) const
        {
            const int MaxGlobal = 8;
            const int MaxOutput = 16;
            const int MaxLocal = 24;
            const int MaxInput = 32;
            if (reg == FramePointerReg)
                ccprintf(os, "%%fp");
            else if (reg == StackPointerReg)
                ccprintf(os, "%%sp");
            else if(reg < MaxGlobal)
                ccprintf(os, "%%g%d", reg);
            else if(reg < MaxOutput)
                ccprintf(os, "%%o%d", reg - MaxGlobal);
            else if(reg < MaxLocal)
                ccprintf(os, "%%l%d", reg - MaxOutput);
            else if(reg < MaxInput)
                ccprintf(os, "%%i%d", reg - MaxLocal);
            else {
                ccprintf(os, "%%f%d", reg - FP_Base_DepTag);
            }
        }

        std::string SparcStaticInst::generateDisassembly(Addr pc,
            const SymbolTable *symtab) const
        {
            std::stringstream ss;

            printMnemonic(ss, mnemonic);

            // just print the first two source regs... if there's
            // a third one, it's a read-modify-write dest (Rc),
            // e.g. for CMOVxx
            if(_numSrcRegs > 0)
            {
                printReg(ss, _srcRegIdx[0]);
            }
            if(_numSrcRegs > 1)
            {
                ss << ",";
                printReg(ss, _srcRegIdx[1]);
            }

            // just print the first dest... if there's a second one,
            // it's generally implicit
            if(_numDestRegs > 0)
            {
                if(_numSrcRegs > 0)
                    ss << ",";
                    printReg(ss, _destRegIdx[0]);
            }

            return ss.str();
        }

        bool passesCondition(uint32_t codes, uint32_t condition)
        {
            CondCodes condCodes;
            condCodes.bits = codes;
            switch(condition)
            {
              case Always:
                return true;
              case Never:
                return false;
              case NotEqual:
                return !condCodes.z;
              case Equal:
                return condCodes.z;
              case Greater:
                return !(condCodes.z | (condCodes.n ^ condCodes.v));
              case LessOrEqual:
                return condCodes.z | (condCodes.n ^ condCodes.v);
              case GreaterOrEqual:
                return !(condCodes.n ^ condCodes.v);
              case Less:
                return (condCodes.n ^ condCodes.v);
              case GreaterUnsigned:
                return !(condCodes.c | condCodes.z);
              case LessOrEqualUnsigned:
                return (condCodes.c | condCodes.z);
              case CarryClear:
                return !condCodes.c;
              case CarrySet:
                return condCodes.c;
              case Positive:
                return !condCodes.n;
              case Negative:
                return condCodes.n;
              case OverflowClear:
                return !condCodes.v;
              case OverflowSet:
                return condCodes.v;
            }
            panic("Tried testing condition nonexistant "
                    "condition code %d", condition);
        }
}};

