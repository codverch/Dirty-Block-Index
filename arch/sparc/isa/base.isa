////////////////////////////////////////////////////////////////////
//
// Base class for sparc instructions, and some support functions
//

output header {{

        union CondCodes
        {
            struct
            {
                uint8_t c:1;
                uint8_t v:1;
                uint8_t z:1;
                uint8_t n:1;
            };
            uint32_t bits;
        };

        enum CondTest
        {
            Always=0x8,
            Never=0x0,
            NotEqual=0x9,
            Equal=0x1,
            Greater=0xA,
            LessOrEqual=0x2,
            GreaterOrEqual=0xB,
            Less=0x3,
            GreaterUnsigned=0xC,
            LessOrEqualUnsigned=0x4,
            CarryClear=0xD,
            CarrySet=0x5,
            Positive=0xE,
            Negative=0x6,
            OverflowClear=0xF,
            OverflowSet=0x7
        };

        /**
         * Base class for all SPARC static instructions.
         */
        class SparcStaticInst : public StaticInst
        {
          protected:
            // Constructor.
            SparcStaticInst(const char *mnem,
                 MachInst _machInst, OpClass __opClass)
                    : StaticInst(mnem, _machInst, __opClass)
                {
                }

            std::string generateDisassembly(Addr pc,
                const SymbolTable *symtab) const;

            void printReg(std::ostream &os, int reg) const;
        };

        bool passesCondition(uint32_t codes, uint32_t condition);
}};

def template ROrImmDecode {{
    {
        return (I ? (SparcStaticInst *)(new %(class_name)sImm(machInst))
                  : (SparcStaticInst *)(new %(class_name)s(machInst)));
    }
}};

let {{
    def splitOutImm(code):
        matcher = re.compile(r'Rs(?P<rNum>\d)_or_imm(?P<iNum>d{0,2})')
        rOrImmMatch = matcher.search(code)
        if (rOrImmMatch == None):
            return (False, CodeBlock(code), None, '', '')
        rString = matcher.sub(r'(?P=rNum)', rOrImmMatch.string)
        iString = matcher.sub(r'(?P=iNum)', rOrImmMatch.string)
        orig_code = code
        code = matcher.sub(r'Rs(?P<rNum>)', orig_code)
        imm_code = matcher.sub('imm', orig_code)
        return (True, CodeBlock(code), CodeBlock(imm_code), rString, iString)
}};

output decoder {{

        void
        SparcStaticInst::printReg(std::ostream &os, int reg) const
        {
            if (reg < FP_Base_DepTag) {
                ccprintf(os, "r%d", reg);
            }
            else {
                ccprintf(os, "f%d", reg - FP_Base_DepTag);
            }
        }

        std::string SparcStaticInst::generateDisassembly(Addr pc,
            const SymbolTable *symtab) const
        {
            std::stringstream ss;

            ccprintf(ss, "%-10s ", mnemonic);

            // just print the first two source regs... if there's
            // a third one, it's a read-modify-write dest (Rc),
            // e.g. for CMOVxx
            if(_numSrcRegs > 0)
            {
                printReg(ss, _srcRegIdx[0]);
            }
            if(_numSrcRegs > 1)
            {
                ss << ",";
                printReg(ss, _srcRegIdx[1]);
            }

            // just print the first dest... if there's a second one,
            // it's generally implicit
            if(_numDestRegs > 0)
            {
                if(_numSrcRegs > 0)
                    ss << ",";
                    printReg(ss, _destRegIdx[0]);
            }

            return ss.str();
        }

        bool passesCondition(uint32_t codes, uint32_t condition)
        {
            CondCodes condCodes;
            condCodes.bits = codes;
            switch(condition)
            {
              case Always:
                return true;
              case Never:
                return false;
              case NotEqual:
                return !condCodes.z;
              case Equal:
                return condCodes.z;
              case Greater:
                return !(condCodes.z | (condCodes.n ^ condCodes.v));
              case LessOrEqual:
                return condCodes.z | (condCodes.n ^ condCodes.v);
              case GreaterOrEqual:
                return !(condCodes.n ^ condCodes.v);
              case Less:
                return (condCodes.n ^ condCodes.v);
              case GreaterUnsigned:
                return !(condCodes.c | condCodes.z);
              case LessOrEqualUnsigned:
                return (condCodes.c | condCodes.z);
              case CarryClear:
                return !condCodes.c;
              case CarrySet:
                return condCodes.c;
              case Positive:
                return !condCodes.n;
              case Negative:
                return condCodes.n;
              case OverflowClear:
                return !condCodes.v;
              case OverflowSet:
                return condCodes.v;
            }
            panic("Tried testing condition nonexistant "
                    "condition code %d", condition);
        }
}};

