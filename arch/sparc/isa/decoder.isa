////////////////////////////////////////////////////////////////////
//
// The actual decoder specification
//

decode OP default Unknown::unknown()
{
    0x0: decode OP2
    {
        //Throw an illegal instruction acception
        0x0: Trap::illtrap({{fault = new IllegalInstruction;}});
        0x1: decode BPCC
        {
            format Branch19
            {
                0x0: bpcci({{
                    if(passesCondition(CcrIcc, COND2))
                        NNPC = xc->readPC() + disp;
                }});
                0x2: bpccx({{
                    if(passesCondition(CcrXcc, COND2))
                        NNPC = xc->readPC() + disp;
                }});
            }
        }
        0x2: Branch22::bicc({{
            if(passesCondition(CcrIcc, COND2))
                NNPC = xc->readPC() + disp;
        }});
        0x3: decode RCOND2
        {
            format BranchSplit
            {
                0x1: bpreq({{
                    if(Rs1 == 0)
                        NNPC = xc->readPC() + disp;
                }});
                0x2: bprle({{
                    if(Rs1 <= 0)
                        NNPC = xc->readPC() + disp;
                }});
                0x3: bprl({{
                    if(Rs1 < 0)
                        NNPC = xc->readPC() + disp;
                }});
                0x5: bprne({{
                    if(Rs1 != 0)
                        NNPC = xc->readPC() + disp;
                }});
                0x6: bprg({{
                    if(Rs1 > 0)
                        NNPC = xc->readPC() + disp;
                }});
                0x7: bprge({{
                    if(Rs1 >= 0)
                        NNPC = xc->readPC() + disp;
                }});
            }
        }
        //SETHI (or NOP if rd == 0 and imm == 0)
        0x4: SetHi::sethi({{Rd = imm;}});
        0x5: Trap::fbpfcc({{fault = new FpDisabled;}});
        0x6: Trap::fbfcc({{fault = new FpDisabled;}});
    }
    0x1: Branch30::call({{
            R15 = xc->readPC();
            NNPC = R15 + disp;
    }});
    0x2: decode OP3 {
        format IntOp {
            0x00: add({{Rd = Rs1.sdw + Rs2_or_imm13;}});
            0x01: and({{Rd = Rs1.udw & Rs2_or_imm13;}});
            0x02: or({{Rd = Rs1.udw | Rs2_or_imm13;}});
            0x03: xor({{Rd = Rs1.udw ^ Rs2_or_imm13;}});
            0x04: sub({{Rd = Rs1.sdw - Rs2_or_imm13;}});
            0x05: andn({{Rd = Rs1.udw & ~Rs2_or_imm13;}});
            0x06: orn({{Rd = Rs1.udw | ~Rs2_or_imm13;}});
            0x07: xnor({{Rd = ~(Rs1.udw ^ Rs2_or_imm13);}});
            0x08: addc({{Rd = Rs1.sdw + Rs2_or_imm13 + CcrIccC;}});
            0x09: mulx({{Rd = Rs1 * Rs2_or_imm13;}});
            0x0A: umul({{
                Rd = Rs1.udw<31:0> * Rs2_or_imm13<31:0>;
                YValue = Rd<63:32>;
            }});
            0x0B: smul({{
                Rd.sdw = Rs1.sdw<31:0> * Rs2_or_imm13<31:0>;
                YValue = Rd.sdw;
            }});
            0x0C: subc({{Rd.sdw = Rs1.sdw + (~Rs2_or_imm13) + 1 + CcrIccC;}});
            0x0D: udivx({{
                if(Rs2_or_imm13 == 0) fault = new DivisionByZero;
                else Rd.udw = Rs1.udw / Rs2_or_imm13;
            }});
            0x0E: udiv({{
                if(Rs2_or_imm13 == 0) fault = new DivisionByZero;
                else
                {
                    Rd.udw = ((YValue << 32) | Rs1.udw<31:0>) / Rs2_or_imm13;
                    if(Rd.udw >> 32 != 0)
                        Rd.udw = 0xFFFFFFFF;
                }
            }});
            0x0F: sdiv({{
                if(Rs2_or_imm13 == 0)
                    fault = new DivisionByZero;
                else
                {
                    Rd.udw = ((YValue << 32) | Rs1.sdw<31:0>) / Rs2_or_imm13;
                    if(Rd.udw<63:31> != 0)
                        Rd.udw = 0x7FFFFFFF;
                    else if(Rd.udw<63:> && Rd.udw<62:31> != 0xFFFFFFFF)
                        Rd.udw = 0xFFFFFFFF80000000;
                }
            }});
        }
        format IntOpCc {
            0x10: addcc({{
                int64_t resTemp, val2 = Rs2_or_imm13;
                Rd = resTemp = Rs1 + val2;}},
                {{((Rs1 & 0xFFFFFFFF + val2 & 0xFFFFFFFF) >> 31)}},
                {{Rs1<31:> == val2<31:> && val2<31:> != resTemp<31:>}},
                {{((Rs1 >> 1) + (val2 >> 1) + (Rs1 & val2 & 0x1))<63:>}},
                {{Rs1<63:> == val2<63:> && val2<63:> != resTemp<63:>}}
            );
            0x11: IntOpCcRes::andcc({{Rd = Rs1 & Rs2_or_imm13;}});
            0x12: IntOpCcRes::orcc({{Rd = Rs1 | Rs2_or_imm13;}});
            0x13: IntOpCcRes::xorcc({{Rd = Rs1 ^ Rs2_or_imm13;}});
            0x14: subcc({{
                int64_t resTemp, val2 = Rs2_or_imm13;
                Rd = resTemp = Rs1 - val2;}},
                {{((Rs1 & 0xFFFFFFFF - val2 & 0xFFFFFFFF) >> 31)}},
                {{Rs1<31:> != val2<31:> && Rs1<31:> != resTemp<31:>}},
                {{(((Rs1 >> 1) + (~val2) >> 1) +
                    ((Rs1 | ~val2) & 0x1))<63:>}},
                {{Rs1<63:> != val2<63:> && Rs1<63:> != resTemp<63:>}}
            );
            0x15: IntOpCcRes::andncc({{Rd = Rs1 & ~Rs2_or_imm13;}});
            0x16: IntOpCcRes::orncc({{Rd = Rs1 | ~Rs2_or_imm13;}});
            0x17: IntOpCcRes::xnorcc({{Rd = ~(Rs1 ^ Rs2_or_imm13);}});
            0x18: addccc({{
                int64_t resTemp, val2 = Rs2_or_imm13;
                int64_t carryin = CcrIccC;
                Rd = resTemp = Rs1 + val2 + carryin;}},
                {{((Rs1 & 0xFFFFFFFF + val2 & 0xFFFFFFFF) >> 31
                    + carryin)}},
                {{Rs1<31:> == val2<31:> && val2<31:> != resTemp<31:>}},
                {{((Rs1 >> 1) + (val2 >> 1) +
                    ((Rs1 & val2) | (carryin & (Rs1 | val2)) & 0x1))<63:>}},
                {{Rs1<63:> == val2<63:> && val2<63:> != resTemp<63:>}}
            );
            0x1A: umulcc({{
                uint64_t resTemp, val2 = Rs2_or_imm13;
                Rd = resTemp = Rs1.udw<31:0> * val2<31:0>;
                YValue = resTemp<63:32>;}},
                {{0}},{{0}},{{0}},{{0}});
            0x1B: smulcc({{
                int64_t resTemp, val2 = Rs2_or_imm13;
                Rd = resTemp = Rs1.sdw<31:0> * val2<31:0>;
                YValue = resTemp<63:32>;}},
                {{0}},{{0}},{{0}},{{0}});
            0x1C: subccc({{
                int64_t resTemp, val2 = Rs2_or_imm13;
                int64_t carryin = CcrIccC;
                Rd = resTemp = Rs1 + ~(val2 + carryin) + 1;}},
                {{((Rs1 & 0xFFFFFFFF + (~(val2 + carryin)) & 0xFFFFFFFF + 1) >> 31)}},
                {{Rs1<31:> != val2<31:> && Rs1<31:> != resTemp<31:>}},
                {{(((Rs1 >> 1) + (~(val2 + carryin)) >> 1) + ((Rs1 | ~(val2+carryin)) & 0x1))<63:>}},
                {{Rs1<63:> != val2<63:> && Rs1<63:> != resTemp<63:>}}
            );
            0x1D: udivxcc({{
                if(Rs2_or_imm13 == 0) fault = new DivisionByZero;
                else Rd = Rs1.udw / Rs2_or_imm13;}}
                ,{{0}},{{0}},{{0}},{{0}});
            0x1E: udivcc({{
                uint32_t resTemp, val2 = Rs2_or_imm13;
                int32_t overflow;
                if(val2 == 0) fault = new DivisionByZero;
                else
                {
                    resTemp = (uint64_t)((YValue << 32) | Rs1.udw<31:0>) / val2;
                    overflow = (resTemp<63:32> != 0);
                    if(overflow) Rd = resTemp = 0xFFFFFFFF;
                    else Rd = resTemp;
                } }},
                {{0}},
                {{overflow}},
                {{0}},
                {{0}}
            );
            0x1F: sdivcc({{
                int32_t resTemp, val2 = Rs2_or_imm13;
                int32_t overflow, underflow;
                if(val2 == 0) fault = new DivisionByZero;
                else
                {
                    Rd = resTemp = (int64_t)((YValue << 32) | Rs1.sdw<31:0>) / val2;
                    overflow = (resTemp<63:31> != 0);
                    underflow = (resTemp<63:> && resTemp<62:31> != 0xFFFFFFFF);
                    if(overflow) Rd = resTemp = 0x7FFFFFFF;
                    else if(underflow) Rd = resTemp = 0xFFFFFFFF80000000;
                    else Rd = resTemp;
                } }},
                {{0}},
                {{overflow || underflow}},
                {{0}},
                {{0}}
            );
            0x20: taddcc({{
                int64_t resTemp, val2 = Rs2_or_imm13;
                Rd = resTemp = Rs1 + val2;
                int32_t overflow = Rs1<1:0> || val2<1:0> || (Rs1<31:> == val2<31:> && val2<31:> != resTemp<31:>);}},
                {{((Rs1 & 0xFFFFFFFF + val2 & 0xFFFFFFFF) >> 31)}},
                {{overflow}},
                {{((Rs1 >> 1) + (val2 >> 1) + (Rs1 & val2 & 0x1))<63:>}},
                {{Rs1<63:> == val2<63:> && val2<63:> != resTemp<63:>}}
            );
            0x21: tsubcc({{
                int64_t resTemp, val2 = Rs2_or_imm13;
                Rd = resTemp = Rs1 + val2;
                int32_t overflow = Rs1<1:0> || val2<1:0> || (Rs1<31:> == val2<31:> && val2<31:> != resTemp<31:>);}},
                {{(Rs1 & 0xFFFFFFFF + val2 & 0xFFFFFFFF) >> 31}},
                {{overflow}},
                {{((Rs1 >> 1) + (val2 >> 1) + (Rs1 & val2 & 0x1))<63:>}},
                {{Rs1<63:> == val2<63:> && val2<63:> != resTemp<63:>}}
            );
            0x22: taddcctv({{
                int64_t resTemp, val2 = Rs2_or_imm13;
                Rd = resTemp = Rs1 + val2;
                int32_t overflow = Rs1<1:0> || val2<1:0> || (Rs1<31:> == val2<31:> && val2<31:> != resTemp<31:>);
                if(overflow) fault = new TagOverflow;}},
                {{((Rs1 & 0xFFFFFFFF + val2 & 0xFFFFFFFF) >> 31)}},
                {{overflow}},
                {{((Rs1 >> 1) + (val2 >> 1) + (Rs1 & val2 & 0x1))<63:>}},
                {{Rs1<63:> == val2<63:> && val2<63:> != resTemp<63:>}}
            );
            0x23: tsubcctv({{
                int64_t resTemp, val2 = Rs2_or_imm13;
                Rd = resTemp = Rs1 + val2;
                int32_t overflow = Rs1<1:0> || val2<1:0> || (Rs1<31:> == val2<31:> && val2<31:> != resTemp<31:>);
                if(overflow) fault = new TagOverflow;}},
                {{((Rs1 & 0xFFFFFFFF + val2 & 0xFFFFFFFF) >> 31)}},
                {{overflow}},
                {{((Rs1 >> 1) + (val2 >> 1) + (Rs1 & val2 & 0x1))<63:>}},
                {{Rs1<63:> == val2<63:> && val2<63:> != resTemp<63:>}}
            );
            0x24: mulscc({{
                int64_t resTemp, multiplicand = Rs2_or_imm13;
                int32_t multiplier = Rs1<31:0>;
                int32_t savedLSB = Rs1<0:>;
                multiplier = multiplier<31:1> |
                    ((CcrIccN
                    ^ CcrIccV) << 32);
                if(!YValue<0:>)
                    multiplicand = 0;
                Rd = resTemp = multiplicand + multiplier;
                YValue = YValue<31:1> | (savedLSB << 31);}},
                {{((multiplicand & 0xFFFFFFFF + multiplier & 0xFFFFFFFF) >> 31)}},
                {{multiplicand<31:> == multiplier<31:> && multiplier<31:> != resTemp<31:>}},
                {{((multiplicand >> 1) + (multiplier >> 1) + (multiplicand & multiplier & 0x1))<63:>}},
                {{multiplicand<63:> == multiplier<63:> && multiplier<63:> != resTemp<63:>}}
            );
        }
        format IntOp
        {
            0x25: decode X {
                0x0: sll({{Rd = Rs1 << (I ? SHCNT32 : Rs2<4:0>);}});
                0x1: sllx({{Rd = Rs1 << (I ? SHCNT64 : Rs2<5:0>);}});
            }
            0x26: decode X {
                0x0: srl({{Rd = Rs1.uw >> (I ? SHCNT32 : Rs2<4:0>);}});
                0x1: srlx({{Rd = Rs1.udw >> (I ? SHCNT64 : Rs2<5:0>);}});
            }
            0x27: decode X {
                0x0: sra({{Rd = Rs1.sw >> (I ? SHCNT32 : Rs2<4:0>);}});
                0x1: srax({{Rd = Rs1.sdw >> (I ? SHCNT64 : Rs2<5:0>);}});
            }
            0x28: decode RS1 {
                0x0: rdy({{Rd = YValue;}});
                0x2: rdccr({{Rd = Ccr;}});
                0x3: rdasi({{Rd = Asi;}});
                0x4: PrivTick::rdtick({{Rd = Tick;}});
                0x5: rdpc({{Rd = xc->readPC();}});
                0x6: rdfprs({{Rd = Fprs;}});
                0xF: decode I {
                    0x0: Nop::membar({{/*Membar isn't needed yet*/}});
                    0x1: Nop::stbar({{/*Stbar isn't needed yet*/}});
                }
            }
            0x2A: decode RS1 {
                format Priv
                {
                    0x0: rdprtpc({{
                        Rd = xc->readMiscReg(MISCREG_TPC_BASE + Tl);
                    }});
                    0x1: rdprtnpc({{
                        Rd = xc->readMiscReg(MISCREG_TNPC_BASE + Tl);
                    }});
                    0x2: rdprtstate({{
                        Rd = xc->readMiscReg(MISCREG_TSTATE_BASE + Tl);
                    }});
                    0x3: rdprtt({{
                        Rd = xc->readMiscReg(MISCREG_TT_BASE + Tl);
                    }});
                    0x4: rdprtick({{Rd = Tick;}});
                    0x5: rdprtba({{Rd = Tba;}});
                    0x6: rdprpstate({{Rd = Pstate;}});
                    0x7: rdprtl({{Rd = Tl;}});
                    0x8: rdprpil({{Rd = Pil;}});
                    0x9: rdprcwp({{Rd = Cwp;}});
                    0xA: rdprcansave({{Rd = Cansave;}});
                    0xB: rdprcanrestore({{Rd = Canrestore;}});
                    0xC: rdprcleanwin({{Rd = Cleanwin;}});
                    0xD: rdprotherwin({{Rd = Otherwin;}});
                    0xE: rdprwstate({{Rd = Wstate;}});
                }
                //The floating point queue isn't implemented right now.
                0xF: Trap::rdprfq({{fault = new IllegalInstruction;}});
                0x1F: Priv::rdprver({{Rd = Ver;}});
            }
            0x2B: BasicOperate::flushw({{
                if(NWindows - 2 - Cansave == 0)
                {
                    if(Otherwin)
                        fault = new SpillNOther(WstateOther);
                    else
                        fault = new SpillNNormal(WstateNormal);
                }
            }});
            0x2C: decode MOVCC3
            {
                0x0: Trap::movccfcc({{fault = new FpDisabled;}});
                0x1: decode CC
                {
                    0x0: movcci({{
                        if(passesCondition(CcrIcc, COND4))
                            Rd = (I ? SIMM11 : RS2);
                    }});
                    0x2: movccx({{
                        if(passesCondition(CcrXcc, COND4))
                            Rd = (I ? SIMM11 : RS2);
                    }});
                }
            }
            0x2D: sdivx({{
                if(Rs2_or_imm13 == 0) fault = new DivisionByZero;
                else Rd.sdw = Rs1.sdw / Rs2_or_imm13;
            }});
            0x2E: decode RS1 {
                0x0: IntOp::popc({{
                    int64_t count = 0;
                    uint64_t temp = Rs2_or_imm13;
                    //Count the 1s in the front 4bits until none are left
                    uint8_t oneBits[] = {0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4};
                    while(temp)
                    {
                            count += oneBits[temp & 0xF];
                            temp = temp >> 4;
                    }
                }});
            }
            0x2F: decode RCOND3
            {
                0x1: movreq({{if(Rs1 == 0) Rd = Rs2_or_imm10;}});
                0x2: movrle({{if(Rs1 <= 0) Rd = Rs2_or_imm10;}});
                0x3: movrl({{if(Rs1 < 0) Rd = Rs2_or_imm10;}});
                0x5: movrne({{if(Rs1 != 0) Rd = Rs2_or_imm10;}});
                0x6: movrg({{if(Rs1 > 0) Rd = Rs2_or_imm10;}});
                0x7: movrge({{if(Rs1 >= 0) Rd = Rs2_or_imm10;}});
            }
            0x30: decode RD {
                0x0: wry({{Y = Rs1 ^ Rs2_or_imm13;}});
                0x2: wrccr({{Ccr = Rs1 ^ Rs2_or_imm13;}});
                0x3: wrasi({{Asi = Rs1 ^ Rs2_or_imm13;}});
                0x6: wrfprs({{Asi = Rs1 ^ Rs2_or_imm13;}});
                0xF: Trap::sir({{fault = new SoftwareInitiatedReset;}});
            }
            0x31: decode FCN {
                0x0: BasicOperate::saved({{/*Boogy Boogy*/}});
                0x1: BasicOperate::restored({{/*Boogy Boogy*/}});
            }
            0x32: decode RD {
                format Priv
                {
                    0x0: wrprtpc({{
                        xc->setMiscReg(MISCREG_TPC_BASE + Tl,
                            Rs1 ^ Rs2_or_imm13);
                    }});
                    0x1: wrprtnpc({{
                        xc->setMiscReg(MISCREG_TNPC_BASE + Tl,
                            Rs1 ^ Rs2_or_imm13);
                    }});
                    0x2: wrprtstate({{
                        xc->setMiscReg(MISCREG_TSTATE_BASE + Tl,
                            Rs1 ^ Rs2_or_imm13);
                    }});
                    0x3: wrprtt({{
                        xc->setMiscReg(MISCREG_TT_BASE + Tl,
                            Rs1 ^ Rs2_or_imm13);
                    }});
                    0x4: wrprtick({{Tick = Rs1 ^ Rs2_or_imm13;}});
                    0x5: wrprtba({{Tba = Rs1 ^ Rs2_or_imm13;}});
                    0x6: wrprpstate({{Pstate = Rs1 ^ Rs2_or_imm13;}});
                    0x7: wrprtl({{Tl = Rs1 ^ Rs2_or_imm13;}});
                    0x8: wrprpil({{Pil = Rs1 ^ Rs2_or_imm13;}});
                    0x9: wrprcwp({{Cwp = Rs1 ^ Rs2_or_imm13;}});
                    0xA: wrprcansave({{Cansave = Rs1 ^ Rs2_or_imm13;}});
                    0xB: wrprcanrestore({{Canrestore = Rs1 ^ Rs2_or_imm13;}});
                    0xC: wrprcleanwin({{Cleanwin = Rs1 ^ Rs2_or_imm13;}});
                    0xD: wrprotherwin({{Otherwin = Rs1 ^ Rs2_or_imm13;}});
                    0xE: wrprwstate({{Wstate = Rs1 ^ Rs2_or_imm13;}});
                }
            }
            0x34: Trap::fpop1({{fault = new FpDisabled;}});
            0x35: Trap::fpop2({{fault = new FpDisabled;}});
            0x38: Branch::jmpl({{
                Addr target = Rs1 + Rs2_or_imm13;
                if(target & 0x3)
                    fault = new MemAddressNotAligned;
                else
                {
                    Rd = xc->readPC();
                    NNPC = target;
                }
            }});
            0x39: Branch::return({{
                Addr target = Rs1 + Rs2_or_imm13;
                if(target & 0x3)
                    fault = new MemAddressNotAligned;
                else
                    NNPC = target;
                //This needs to change the register window
                //like restore does
            }});
            0x3A: decode CC
            {
                0x0: Trap::tcci({{
#if FULL_SYSTEM
                    fault = new TrapInstruction;
#else
                    if(passesCondition(CcrIcc, machInst<25:28>))
                    {
                        // At least glibc only uses trap 0,
                        // solaris/sunos may use others
                        assert((I ? Rs1 + Rs2 : Rs1 + SW_TRAP) == 0);
                        xc->syscall();
                    }
#endif
                }});
                0x2: Trap::tccx({{
#if FULL_SYSTEM
                    fault = new TrapInstruction;
#else
                    if(passesCondition(CcrXcc, machInst<25:28>))
                    {
                        // At least glibc only uses trap 0,
                        // solaris/sunos may use others
                        assert((I ? Rs1 + Rs2 : Rs1 + SW_TRAP) == 0);
                        xc->syscall();
                    }
#endif
                }});
            }
            0x3B: Nop::flush({{/*Instruction memory flush*/}});
            0x3C: save({{
                //CWP should be set directly so that it always happens
                //Also, this will allow writing to the new window and
                //reading from the old one
                if(Cansave == 0)
                {
                    if(Otherwin)
                        fault = new SpillNOther(WstateOther);
                    else
                        fault = new SpillNNormal(WstateNormal);
                    Cwp = (Cwp + 2) % NWindows;
                }
                else if(Cleanwin - Canrestore == 0)
                {
                    Cwp = (Cwp + 1) % NWindows;
                    fault = new CleanWindow;
                }
                else
                {
                    Cwp = (Cwp + 1) % NWindows;
                    Rd = Rs1 + Rs2_or_imm13;
                    Cansave--;
                    Canrestore++;
                }
                //This is here to make sure the CWP is written
                //no matter what. This ensures that the results
                //are written in the new window as well.
                xc->setMiscRegWithEffect(MISCREG_CWP, Cwp);
            }});
            0x3D: restore({{
                //CWP should be set directly so that it always happens
                //Also, this will allow writing to the new window and
                //reading from the old one
                Cwp = (Cwp - 1 + NWindows) % NWindows;
                if(Canrestore == 0)
                {
                    if(Otherwin)
                        fault = new FillNOther(WstateOther);
                    else
                        fault = new FillNNormal(WstateNormal);
                }
                else
                {
                    Rd = Rs1 + Rs2_or_imm13;
                    Cansave++;
                    Canrestore--;
                }
                //This is here to make sure the CWP is written
                //no matter what. This ensures that the results
                //are written in the new window as well.
                xc->setMiscRegWithEffect(MISCREG_CWP, Cwp);
            }});
            0x3E: decode FCN {
                0x0: Priv::done({{
                    if(Tl == 0)
                        return new IllegalInstruction;
                    Cwp = xc->readMiscReg(MISCREG_TSTATE_CWP_BASE + Tl);
                    Asi = xc->readMiscReg(MISCREG_TSTATE_ASI_BASE + Tl);
                    Ccr = xc->readMiscReg(MISCREG_TSTATE_CCR_BASE + Tl);
                    Pstate = xc->readMiscReg(MISCREG_TSTATE_PSTATE_BASE + Tl);
                    NPC = xc->readMiscReg(MISCREG_TNPC_BASE + Tl);
                    NNPC = NPC + 4;
                    Tl = Tl - 1;
                }});
                0x1: BasicOperate::retry({{
                    if(Tl == 0)
                        return new IllegalInstruction;
                    Cwp = xc->readMiscReg(MISCREG_TSTATE_CWP_BASE + Tl);
                    Asi = xc->readMiscReg(MISCREG_TSTATE_ASI_BASE + Tl);
                    Ccr = xc->readMiscReg(MISCREG_TSTATE_CCR_BASE + Tl);
                    Pstate = xc->readMiscReg(MISCREG_TSTATE_PSTATE_BASE + Tl);
                    NPC = xc->readMiscReg(MISCREG_TPC_BASE + Tl);
                    NNPC = xc->readMiscReg(MISCREG_TNPC_BASE + Tl);
                    Tl = Tl - 1;
                }});
            }
        }
    }
    0x3: decode OP3 {
        format Load {
            0x00: lduw({{Rd = Mem;}}, {{32}});
            0x01: ldub({{Rd = Mem;}}, {{8}});
            0x02: lduh({{Rd = Mem;}}, {{16}});
            0x03: ldd({{
                uint64_t val = Mem;
                RdLow = val<31:0>;
                RdHigh = val<63:32>;
            }}, {{64}});
        }
        format Store {
            0x04: stw({{Mem = Rd.sw;}}, {{32}});
            0x05: stb({{Mem = Rd.sb;}}, {{8}});
            0x06: sth({{Mem = Rd.shw;}}, {{16}});
            0x07: std({{Mem = RdLow<31:0> | RdHigh<31:0> << 32;}}, {{64}});
        }
        format Load {
            0x08: ldsw({{Rd = (int32_t)Mem;}}, {{32}});
            0x09: ldsb({{Rd = (int8_t)Mem;}}, {{8}});
            0x0A: ldsh({{Rd = (int16_t)Mem;}}, {{16}});
            0x0B: ldx({{Rd = (int64_t)Mem;}}, {{64}});
            0x0D: ldstub({{
                Rd = Mem;
                Mem = 0xFF;
            }}, {{8}});
        }
        0x0E: Store::stx({{Mem = Rd}}, {{64}});
        0x0F: LoadStore::swap({{
            uint32_t temp = Rd;
            Rd = Mem;
            Mem = temp;
        }}, {{32}});
        format Load {
            0x10: lduwa({{Rd = Mem;}}, {{32}});
            0x11: lduba({{Rd = Mem;}}, {{8}});
            0x12: lduha({{Rd = Mem;}}, {{16}});
            0x13: ldda({{
                uint64_t val = Mem;
                RdLow = val<31:0>;
                RdHigh = val<63:32>;
            }}, {{64}});
        }
        format Store {
            0x14: stwa({{Mem = Rd;}}, {{32}});
            0x15: stba({{Mem = Rd;}}, {{8}});
            0x16: stha({{Mem = Rd;}}, {{16}});
            0x17: stda({{Mem = RdLow<31:0> | RdHigh<31:0> << 32;}}, {{64}});
        }
        format Load {
            0x18: ldswa({{Rd = (int32_t)Mem;}}, {{32}});
            0x19: ldsba({{Rd = (int8_t)Mem;}}, {{8}});
            0x1A: ldsha({{Rd = (int16_t)Mem;}}, {{16}});
            0x1B: ldxa({{Rd = (int64_t)Mem;}}, {{64}});
        }
        0x1D: LoadStore::ldstuba({{
            Rd = Mem;
            Mem = 0xFF;
        }}, {{8}});
        0x1E: Store::stxa({{Mem = Rd}}, {{64}});
        0x1F: LoadStore::swapa({{
            uint32_t temp = Rd;
            Rd = Mem;
            Mem = temp;
        }}, {{32}});
        format Trap {
            0x20: ldf({{fault = new FpDisabled;}});
            0x21: decode X {
                0x0: ldfsr({{fault = new FpDisabled;}});
                0x1: ldxfsr({{fault = new FpDisabled;}});
            }
            0x22: ldqf({{fault = new FpDisabled;}});
            0x23: lddf({{fault = new FpDisabled;}});
            0x24: stf({{fault = new FpDisabled;}});
            0x25: decode X {
                0x0: stfsr({{fault = new FpDisabled;}});
                0x1: stxfsr({{fault = new FpDisabled;}});
            }
            0x26: stqf({{fault = new FpDisabled;}});
            0x27: stdf({{fault = new FpDisabled;}});
            0x2D: Nop::prefetch({{ }});
            0x30: ldfa({{return new FpDisabled;}});
            0x32: ldqfa({{fault = new FpDisabled;}});
            0x33: lddfa({{fault = new FpDisabled;}});
            0x34: stfa({{fault = new FpDisabled;}});
            0x35: stqfa({{fault = new FpDisabled;}});
            0x36: stdfa({{fault = new FpDisabled;}});
            0x3C: Cas::casa({{
                uint64_t val = Mem.uw;
                if(Rs2.uw == val)
                        Mem.uw = Rd.uw;
                Rd.uw = val;
            }});
            0x3D: Nop::prefetcha({{ }});
            0x3E: Cas::casxa({{
                uint64_t val = Mem.udw;
                if(Rs2 == val)
                        Mem.udw = Rd;
                Rd = val;
            }});
        }
    }
}
