////////////////////////////////////////////////////////////////////
//
// The actual decoder specification
//

decode OP default Unknown::unknown()
{
    0x0: decode OP2
    {
        format Branch
        {
            //Throw an illegal instruction acception
            0x0: Trap::illtrap({{fault = new IllegalInstruction;}});
            0x1: decode CC02
            {
                0x0: decode CC12
                {
                    0x0: bpcci({{
                        if(passesCondition(CcrIcc, COND2))
                            ;//branchHere
                    }});
                    0x1: bpccx({{
                    if(passesCondition(CcrXcc, COND2))
                        ;//branchHere
                    }});
                }
            }
            0x2: bicc({{
                if(passesCondition(CcrIcc, COND2))
                    ;//branchHere
            }});
            0x3: decode RCOND2
            {
                0x1: bpreq({{
                    if(Rs1 == 0)
                        ;//branchHere
                }});
                0x2: bprle({{
                    if(Rs1 <= 0)
                        ;//branchHere
                }});
                0x3: bprl({{
                    if(Rs1 < 0)
                        ;//branchHere
                }});
                0x5: bprne({{
                    if(Rs1 != 0)
                        ;//branchHere
                }});
                0x6: bprg({{
                    if(Rs1 > 0)
                        ;//branchHere
                }});
                0x7: bprge({{
                    if(Rs1 >= 0)
                        ;//branchHere
                }});
            }
            //SETHI (or NOP if rd == 0 and imm == 0)
            0x4: IntOp::sethi({{Rd = (IMM22 << 10) & 0xFFFFFC00;}});
            0x5: Trap::fbpfcc({{fault = new FpDisabled;}});
            0x6: Trap::fbfcc({{fault = new FpDisabled;}});
        }
    }
    0x1: Branch::call({{
            //branch here
            Rd = xc->readPC();
    }});
    0x2: decode OP3 {
        format IntOp {
            0x00: add({{Rd = Rs1.sdw + Rs2_or_imm13;}});
            0x01: and({{Rd = Rs1.udw & Rs2_or_imm13;}});
            0x02: or({{Rd = Rs1.udw | Rs2_or_imm13;}});
            0x03: xor({{Rd = Rs1.udw ^ Rs2_or_imm13;}});
            0x04: sub({{Rd = Rs1.sdw + (~Rs2_or_imm)+1;}});
            0x05: andn({{Rd = Rs1.udw & ~Rs2_or_imm;}});
            0x06: orn({{Rd = Rs1.udw | ~Rs2_or_imm;}});
            0x07: xnor({{Rd = ~(Rs1.udw ^ Rs2_or_imm);}});
            0x08: addc({{Rd = Rs1.sdw + Rs2_or_imm + CcrIccC;}});
            0x09: mulx({{Rd = Rs1 * Rs2_or_imm;}});
            0x0A: umul({{
                Rd = Rs1.udw<31:0> * Rs2_or_imm<31:0>;
                YValue = Rd<63:32>;
            }});
            0x0B: smul({{
                Rd.sdw = Rs1.sdw<31:0> * Rs2_or_imm<31:0>;
                YValue = Rd.sdw;
            }});
            0x0C: subc({{Rd.sdw = Rs1.sdw + (~Rs2_or_imm) + 1 + CcrIccC;}});
            0x0D: udivx({{
                if(val2 == 0) fault = new DivisionByZero;
                else Rd.udw = Rs1.udw / Rs2_or_imm;
            }});
            0x0E: udiv({{
                uint32_t resTemp, val2 = (I ? SIMM13 : Rs2.udw<31:0>);
                if(Rs2_or_imm.udw == 0) fault = new DivisionByZero;
                else
                {
                    Rd.udw = ((YValue << 32) | Rs1.udw<31:0>) / Rs2_or_imm.udw;
                    if(Rd.udw >> 32 != 0)
                        Rd.udw = 0xFFFFFFFF;
                }
            }});
            0x0F: sdiv({{
                if(val2 == 0)
                    fault = new DivisionByZero;
                else
                {
                    Rd.udw = ((YValue << 32) | Rs1.sdw<31:0>) / Rs2_or_imm;
                    if(Rd.udw<63:31> != 0)
                        Rd.udw = 0x7FFFFFFF;
                    else if(Rd.udw<63:> && Rd.udw<62:31> != 0xFFFFFFFF)
                        Rd.udw = 0xFFFFFFFF80000000;
                }
            }});//SDIV
        }
        format IntOpCc {
            0x10: addcc({{
                int64_t resTemp, val2 = (I ? SIMM13 : Rs2);
                Rd = resTemp = Rs1 + val2;}},
                {{((Rs1 & 0xFFFFFFFF + val2 & 0xFFFFFFFF) >> 31)}},
                {{Rs1<31:> == val2<31:> && val2<31:> != resTemp<31:>}},
                {{((Rs1 >> 1) + (val2 >> 1) + (Rs1 & val2 & 0x1))<63:>}},
                {{Rs1<63:> == val2<63:> && val2<63:> != resTemp<63:>}}
                );//ADDcc
            0x11: IntOpCcRes::andcc({{Rd = Rs1 & Rs2_or_imm13;}});
            0x12: IntOpCcRes::orcc({{Rd = Rs1 | Rs2_or_imm13;}});
            0x13: IntOpCcRes::xorcc({{Rd = Rs1 ^ Rs2_or_imm13;}});
            0x14: subcc({{
                int64_t resTemp, val2 = (int64_t)(I ? SIMM13 : Rs2);
                Rd = resTemp = Rs1 - val2;}},
                {{((Rs1 & 0xFFFFFFFF + (~val2) & 0xFFFFFFFF + 1) >> 31)}},
                {{Rs1<31:> != val2<31:> && Rs1<31:> != resTemp<31:>}},
                {{((Rs1 >> 1) + (~val2) >> 1) +
                    ((Rs1 | ~val2) & 0x1))<63:>}},
                {{Rs1<63:> != val2<63:> && Rs1<63:> != resTemp<63:>}}
            );//SUBcc
            0x15: IntOpCcRes::andncc({{Rd = Rs1 & ~Rs2_or_imm13;}});
            0x16: IntOpCcRes::orncc({{Rd = Rs1 | ~Rs2_or_imm13;}});
            0x17: IntOpCcRes::xnorcc({{Rd = ~(Rs1 ^ Rs2_or_imm13);}});
            0x18: addccc({{
                int64_t resTemp, val2 = (I ? SIMM13 : Rs2);
                int64_t carryin = CcrIccC;
                Rd = resTemp = Rs1 + val2 + carryin;}},
                {{((Rs1 & 0xFFFFFFFF + val2 & 0xFFFFFFFF) >> 31
                    + carryin)}},
                {{Rs1<31:> == val2<31:> && val2<31:> != resTemp<31:>}},
                {{((Rs1 >> 1) + (val2 >> 1) +
                    ((Rs1 & val2) | (carryin & (Rs1 | val2)) & 0x1))<63:>}},
                {{Rs1<63:> == val2<63:> && val2<63:> != resTemp<63:>}}
            );//ADDCcc
            0x1A: umulcc({{
                uint64_t resTemp, val2 = (I ? SIMM13 : Rs2);
                Rd = resTemp = Rs1.udw<31:0> * val2<31:0>;
                YValue = resTemp<63:32>;}},
                {{0}},{{0}},{{0}},{{0}});//UMULcc
            0x1B: smulcc({{
                int64_t resTemp, val2 = (I ? SIMM13 : Rs2);
                Rd = resTemp = Rs1.sdw<31:0> * val2<31:0>;
                YValue = resTemp<63:32>;}}
                ,{{0}},{{0}},{{0}},{{0}});//SMULcc
            0x1C: subccc({{
                int64_t resTemp, val2 = (int64_t)(I ? SIMM13 : Rs2);
                int64_t carryin = CcrIccC;
                Rd = resTemp = Rs1 + ~(val2 + carryin) + 1;}},
                {{((Rs1 & 0xFFFFFFFF + (~(val2 + carryin)) & 0xFFFFFFFF + 1) >> 31)}},
                {{Rs1<31:> != val2<31:> && Rs1<31:> != resTemp<31:>}},
                {{((Rs1 >> 1) + (~(val2 + carryin)) >> 1) + ((Rs1 | ~(val2+carryin)) & 0x1))<63:>}},
                {{Rs1<63:> != val2<63:> && Rs1<63:> != resTemp<63:>}}
            );//SUBCcc
            0x1D: udivxcc({{
                uint64_t val2 = (I ? SIMM13 : Rs2.udw);
                if(val2 == 0) fault = new DivisionByZero;
                else Rd.udw = Rs1.udw / val2;}}
                ,{{0}},{{0}},{{0}},{{0}});//UDIVXcc
            0x1E: udivcc({{
                uint32_t resTemp, val2 = (I ? SIMM13 : Rs2.udw<31:0>);
                if(val2 == 0) fault = new DivisionByZero;
                else
                {
                    resTemp = (uint64_t)((YValue << 32) | Rs1.udw<31:0>) / val2;
                    int32_t overflow = (resTemp<63:32> != 0);
                    if(overflow) rd.udw = resTemp = 0xFFFFFFFF;
                    else rd.udw = resTemp;
                } }},
                {{0}},
                {{overflow}},
                {{0}},
                {{0}}
            );//UDIVcc
            0x1F: sdivcc({{
                int32_t resTemp, val2 = (I ? SIMM13 : Rs2.sdw<31:0>);
                if(val2 == 0) fault = new DivisionByZero;
                else
                {
                    Rd.sdw = resTemp = (int64_t)((YValue << 32) | Rs1.sdw<31:0>) / val2;
                    int32_t overflow = (resTemp<63:31> != 0);
                    int32_t underflow = (resTemp<63:> && resTemp<62:31> != 0xFFFFFFFF);
                    if(overflow) rd.udw = resTemp = 0x7FFFFFFF;
                    else if(underflow) rd.udw = resTemp = 0xFFFFFFFF80000000;
                    else rd.udw = resTemp;
                } }},
                {{0}},
                {{overflow || underflow}},
                {{0}},
                {{0}}
            );//SDIVcc
            0x20: taddcc({{
                int64_t resTemp, val2 = (I ? SIMM13 : Rs2);
                Rd = resTemp = Rs1 + val2;
                int32_t overflow = Rs1<1:0> || val2<1:0> || (Rs1<31:> == val2<31:> && val2<31:> != resTemp<31:>);}},
                {{((Rs1 & 0xFFFFFFFF + val2 & 0xFFFFFFFF) >> 31)}},
                {{overflow}},
                {{((Rs1 >> 1) + (val2 >> 1) + (Rs1 & val2 & 0x1))<63:>}},
                {{Rs1<63:> == val2<63:> && val2<63:> != resTemp<63:>}}
            );//TADDcc
            0x21: tsubcc({{
                int64_t resTemp, val2 = (I ? SIMM13 : Rs2);
                Rd = resTemp = Rs1 + val2;
                int32_t overflow = Rs1<1:0> || val2<1:0> || (Rs1<31:> == val2<31:> && val2<31:> != resTemp<31:>);}},
                {{(Rs1 & 0xFFFFFFFF + val2 & 0xFFFFFFFF) >> 31)}},
                {{overflow}},
                {{((Rs1 >> 1) + (val2 >> 1) + (Rs1 & val2 & 0x1))<63:>}},
                {{Rs1<63:> == val2<63:> && val2<63:> != resTemp<63:>}}
            );//TSUBcc
            0x22: taddcctv({{
                int64_t resTemp, val2 = (I ? SIMM13 : Rs2);
                Rd = resTemp = Rs1 + val2;
                int32_t overflow = Rs1<1:0> || val2<1:0> || (Rs1<31:> == val2<31:> && val2<31:> != resTemp<31:>);
                if(overflow) fault = new TagOverflow;}},
                {{((Rs1 & 0xFFFFFFFF + val2 & 0xFFFFFFFF) >> 31)}},
                {{overflow}},
                {{((Rs1 >> 1) + (val2 >> 1) + (Rs1 & val2 & 0x1))<63:>}},
                {{Rs1<63:> == val2<63:> && val2<63:> != resTemp<63:>}}
            );//TADDccTV
            0x23: tsubcctv({{
                int64_t resTemp, val2 = (I ? SIMM13 : Rs2);
                Rd = resTemp = Rs1 + val2;
                int32_t overflow = Rs1<1:0> || val2<1:0> || (Rs1<31:> == val2<31:> && val2<31:> != resTemp<31:>);
                if(overflow) fault = new TagOverflow;}},
                {{((Rs1 & 0xFFFFFFFF + val2 & 0xFFFFFFFF) >> 31)}},
                {{overflow}},
                {{((Rs1 >> 1) + (val2 >> 1) + (Rs1 & val2 & 0x1))<63:>}},
                {{Rs1<63:> == val2<63:> && val2<63:> != resTemp<63:>}}
            );//TSUBccTV
            0x24: mulscc({{
                int64_t resTemp, multiplicand = (I ? SIMM13 : Rs2);
                int32_t multiplier = Rs1<31:0>;
                int32_t savedLSB = Rs1<0:>;
                multiplier = multipler<31:1> |
                    ((CcrIccN
                    ^ CcrIccV) << 32);
                if(!YValue<0:>)
                    multiplicand = 0;
                Rd = resTemp = multiplicand + multiplier;
                YValue = YValue<31:1> | (savedLSB << 31);}},
                {{((multiplicand & 0xFFFFFFFF + multiplier & 0xFFFFFFFF) >> 31)}},
                {{multiplicand<31:> == multiplier<31:> && multiplier<31:> != resTemp<31:>}},
                {{((multiplicand >> 1) + (multiplier >> 1) + (multiplicand & multiplier & 0x1))<63:>}},
                {{multiplicand<63:> == multiplier<63:> && multiplier<63:> != resTemp<63:>}}
            );//MULScc
            }
            format IntOp
            {
                0x25: decode X {
                    0x0: sll({{Rd = Rs1 << (I ? SHCNT32 : Rs2<4:0>);}});
                    0x1: sllx({{Rd = Rs1 << (I ? SHCNT64 : Rs2<5:0>);}});
                }
                0x26: decode X {
                    0x0: srl({{Rd = Rs1.uw >> (I ? SHCNT32 : Rs2<4:0>);}});
                    0x1: srlx({{Rd = Rs1.udw >> (I ? SHCNT64 : Rs2<5:0>);}});
                }
                0x27: decode X {
                    0x0: sra({{Rd = Rs1.sw >> (I ? SHCNT32 : Rs2<4:0>);}}); //SRA
                    0x1: srax({{Rd = Rs1.sdw >> (I ? SHCNT64 : Rs2<5:0>);}});//SRAX
                }
                0x28: decode RS1 {
                    0x0: rdy({{Rd = YValue;}}); //RDY
                    0x2: rdccr({{Rd = Ccr;}}); //RDCCR
                    0x3: rdasi({{Rd = Asi;}}); //RDASI
                    0x4: PrivTick::rdtick({{Rd = Tick;}});
                    0x5: rdpc({{Rd = xc->regs.pc;}}); //RDPC
                    0x6: rdfprs({{Rd = Fprs;}}); //RDFPRS
                    0xF: decode I {
                        0x0: Noop::membar({{//Membar isn't needed yet}});
                        0x1: Noop::stbar({{//Stbar isn't needed yet}});
                    }
                }
                0x2A: decode RS1 {
                    format Priv
                    {
                        0x0: rdprtpc({{
                            Rd = xc->readMiscReg(MISCREG_TPC_BASE + Tl);
                            }});
                        0x1: rdprtnpc({{
                            Rd = xc->readMiscReg(MISCREG_TNPC_BASE + Tl);
                            }});
                        0x2: rdprtstate({{
                            Rd = xc->readMiscReg(MISCREG_TSTATE_BASE + Tl);
                            }});
                        0x3: rdprtt({{
                            Rd = xc->readMiscReg(MISCREG_TT_BASE + Tl);
                            }});
                        0x4: rdprtick({{Rd = Tick;}});
                        0x5: rdprtba({{Rd = Tba;}});
                        0x6: rdprpstate({{Rd = Pstate;}});
                        0x7: rdprtl({{Rd = Tl;}});
                        0x8: rdprpil({{Rd = Pil;}});
                        0x9: rdprcwp({{Rd = Cwp;}});
                        0xA: rdprcansave({{Rd = Cansave;}});
                        0xB: rdprcanrestore({{Rd = CanRestore;}});
                        0xC: rdprcleanwin({{Rd = Cleanwin;}});
                        0xD: rdprotherwin({{Rd = Otherwin;}});
                        0xE: rdprwstate({{Rd = Wstate;}});
                    }
                    //The floating point queue isn't implemented right now.
                    0xF: Trap::rdprfq({{fault = IllegalInstruction;}});
                    0x1F: Priv::rdprver({{Rd = Ver;}});
                }
                0x2B: BasicOperate::flushw({{//window toilet}}); //FLUSHW
                0x2C: decode CC2
                {
                    0x0: Trap::movccfcc({{fault = new FpDisabled}});
                    0x1: decode CC04
                    {
                        0x0: decode CC14
                        {
                            0x0: movcci({{
                                if(passesCondition(CcrIcc, COND4))
                                    Rd = (I ? SIMM11 : RS2);
                            }});
                            0x1: movccx({{
                                if(passesCondition(CcrXcc, COND4))
                                    Rd = (I ? SIMM11 : RS2);
                            }});
                        }
                    }
                }
                0x2D: sdivx({{
                        if(Rs2_or_imm13 == 0) fault = new DivisionByZero;
                        else Rd.sdw = Rs1.sdw / Rs2_or_imm13;
                }});//SDIVX
                0x2E: decode RS1 {
                        0x0: IntOp::popc({{
                        int64_t count = 0, val2 = Rs2_or_imm;
                        uint8_t oneBits[] = {0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4};
                        for(unsigned int x = 0; x < 16; x++)
                        {
                                count += oneBits[Rs2_or_imm13 & 0xF];
                                val2 >> 4;
                        }
                        }});//POPC
                }
                0x2F: decode RCOND3
                {
                    0x1: movreq({{if(Rs1 == 0) Rd = Rs2_or_imm10;}});
                    0x2: movrle({{if(Rs1 <= 0) Rd = Rs2_or_imm10;}});
                    0x3: movrl({{if(Rs1 < 0) Rd = Rs2_or_imm10;}});
                    0x5: movrne({{if(Rs1 != 0) Rd = Rs2_or_imm10;}});
                    0x6: movrg({{if(Rs1 > 0) Rd = Rs2_or_imm10;}});
                    0x7: movrge({{if(Rs1 >= 0) Rd = Rs2_or_imm10;}});
                }
                0x30: decode RD {
                        0x0: wry({{Y = Rs1 ^ Rs2_or_imm13;}});
                        0x2: wrccr({{Ccr = Rs1 ^ Rs2_or_imm13;}});
                        0x3: wrasi({{Asi = Rs1 ^ Rs2_or_imm13;}});
                        0x6: wrfprs({{Asi = Rs1 ^ Rs2_or_imm13;}});
                        0xF: Trap::sir({{fault = new SoftwareInitiatedReset;}});
                }
                0x31: decode FCN {
                        0x0: BasicOperate::saved({{//Boogy Boogy}}); //SAVED
                        0x1: BasicOperate::restored({{//Boogy Boogy}}); //RESTORED
                }
                0x32: decode RD {
                    format Priv
                    {
                        0x0: wrprtpc({{
                            xc->setMiscReg(MISCREG_TPC_BASE + Tl,
                                Rs1 ^ Rs2_or_imm13);
                        }});
                        0x1: wrprtnpc({{
                            xc->setMiscReg(MISCREG_TNPC_BASE + Tl,
                                Rs1 ^ Rs2_or_imm13);
                        }});
                        0x2: wrprtstate({{
                            xc->setMiscReg(MISCREG_TSTATE_BASE + Tl,
                                Rs1 ^ Rs2_or_imm13);
                        }});
                        0x3: wrprtt({{
                            xc->setMiscReg(MISCREG_TT_BASE + Tl,
                                Rs1 ^ Rs2_or_imm13);
                        }});
                        0x4: wrprtick({{Tick = Rs1 ^ Rs2_or_imm13;}});
                        0x5: wrprtba({{Tba = Rs1 ^ Rs2_or_imm13;}});
                        0x6: wrprpstate({{Pstate = Rs1 ^ Rs2_or_imm13;}});
                        0x7: wrprtl({{Tl = Rs1 ^ Rs2_or_imm13;}});
                        0x8: wrprpil({{Pil = Rs1 ^ Rs2_or_imm13;}});
                        0x9: wrprcwp({{Cwp = Rs1 ^ Rs2_or_imm13;}});
                        0xA: wrprcansave({{Cansave = Rs1 ^ Rs2_or_imm13;}});
                        0xB: wrprcanrestore({{Canrestore = Rs1 ^ Rs2_or_imm13;}});
                        0xC: wrprcleanwin({{Cleanwin = Rs1 ^ Rs2_or_imm13;}});
                        0xD: wrprotherwin({{Otherwin = Rs1 ^ Rs2_or_imm13;}});
                        0xE: wrprwstate({{Wstate = Rs1 ^ Rs2_or_imm13;}});
                    }
                }

                0x34: Trap::fpop1({{fault = new FpDisabled;}});
                0x35: Trap::fpop2({{fault = new FpDisabled;}});

                0x38: Branch::jmpl({{//Stuff}}); //JMPL
                0x39: Branch::return({{//Other Stuff}}); //RETURN
                0x3A: decode CC04
                {
                    // If CC04 == 1, it's an illegal instruction
                    0x0: decode CC14
                    {
                        0x0: Trap::tcci({{
                            if(passesCondition(CcrIcc, machInst<25:28>))
                                fault = new TrapInstruction;
                        }});
                        0x1: Trap::tccx({{
                            if(passesCondition(CcrXcc, machInst<25:28>))
                                fault = new TrapInstruction;
                        }});
                    }
                }
                0x3B: BasicOperate::flush({{//Lala}}); //FLUSH
                0x3C: BasicOperate::save({{//leprechauns); //SAVE
                0x3D: BasicOperate::restore({{//Eat my short int}}); //RESTORE
                0x3E: decode FCN {
                    0x1: BasicOperate::done({{//Done thing}}); //DONE
                    0x2: BasicOperate::retry({{//Retry thing}}); //RETRY
                }
            }
    }
    0x3: decode OP3 {
            format Mem {
                    0x00: lduw({{Rd.uw = Mem.uw;}}); //LDUW
                    0x01: ldub({{Rd.ub = Mem.ub;}}); //LDUB
                    0x02: lduh({{Rd.uhw = Mem.uhw;}}); //LDUH
                    0x03: ldd({{
                        uint64_t val = Mem.udw;
                        setIntReg(RD & (~1), val<31:0>);
                        setIntReg(RD | 1, val<63:32>);
                    }});//LDD
                    0x04: stw({{Mem.sw = Rd.sw;}}); //STW
                    0x05: stb({{Mem.sb = Rd.sb;}}); //STB
                    0x06: sth({{Mem.shw = Rd.shw;}}); //STH
                    0x07: std({{
                            Mem.udw = readIntReg(RD & (~1))<31:0> | (readIntReg(RD | 1)<31:0> << 32);
                    }});//STD
                    0x08: ldsw({{Rd.sw = Mem.sw;}}); //LDSW
                    0x09: ldsb({{Rd.sb = Mem.sb;}}); //LDSB
                    0x0A: ldsh({{Rd.shw = Mem.shw;}}); //LDSH
                    0x0B: ldx({{Rd.udw = Mem.udw;}}); //LDX

                    0x0D: ldstub({{
                            Rd.ub = Mem.ub;
                            Mem.ub = 0xFF;
                    }}); //LDSTUB
                    0x0E: stx({{Rd.udw = Mem.udw;}}); //STX
                    0x0F: swap({{
                            uint32_t temp = Rd.uw;
                            Rd.uw = Mem.uw;
                            Mem.uw = temp;
                    }}); //SWAP
                    0x10: lduwa({{Rd.uw = Mem.uw;}}); //LDUWA
                    0x11: lduba({{Rd.ub = Mem.ub;}}); //LDUBA
                    0x12: lduha({{Rd.uhw = Mem.uhw;}}); //LDUHA
                    0x13: ldda({{
                            uint64_t val = Mem.udw;
                            setIntReg(RD & (~1), val<31:0>);
                            setIntReg(RD | 1, val<63:32>);
                    }}); //LDDA
                    0x14: stwa({{Mem.uw = Rd.uw;}}); //STWA
                    0x15: stba({{Mem.ub = Rd.ub;}}); //STBA
                    0x16: stha({{Mem.uhw = Rd.uhw;}}); //STHA
                    0x17: stda({{
                            Mem.udw = readIntReg(RD & (~1))<31:0> | (readIntReg(RD | 1)<31:0> << 32);
                    }}); //STDA
                    0x18: ldswa({{Rd.sw = Mem.sw;}}); //LDSWA
                    0x19: ldsba({{Rd.sb = Mem.sb;}}); //LDSBA
                    0x1A: ldsha({{Rd.shw = Mem.shw;}}); //LDSHA
                    0x1B: ldxa({{Rd.sdw = Mem.sdw;}}); //LDXA

                    0x1D: ldstuba({{
                            Rd.ub = Mem.ub;
                            Mem.ub = 0xFF;
                    }}); //LDSTUBA
                    0x1E: stxa({{Mem.sdw = Rd.sdw}}); //STXA
                    0x1F: swapa({{
                            uint32_t temp = Rd.uw;
                            Rd.uw = Mem.uw;
                            Mem.uw = temp;
                    }}); //SWAPA
                    0x20: Trap::ldf({{fault = new FpDisabled;}});
                    0x21: decode X {
                        0x0: Trap::ldfsr({{fault = new FpDisabled;}});
                        0x1: Trap::ldxfsr({{fault = new FpDisabled;}});
                    }
                    0x22: Trap::ldqf({{fault = new FpDisabled;}});
                    0x23: Trap::lddf({{fault = new FpDisabled;}});
                    0x24: Trap::stf({{fault = new FpDisabled;}});
                    0x25: decode X {
                        0x0: Trap::stfsr({{fault = new FpDisabled;}});
                        0x1: Trap::stxfsr({{fault = new FpDisabled;}});
                    }
                    0x26: Trap::stqf({{fault = new FpDisabled;}});
                    0x27: Trap::stdf({{fault = new FpDisabled;}});

                    0x2D: Noop::prefetch({{ }}); //PREFETCH

                    0x30: Trap::ldfa({{return new FpDisabled;}});

                    0x32: Trap::ldqfa({{fault = new FpDisabled;}});
                    0x33: Trap::lddfa({{fault = new FpDisabled;}});
                    0x34: Trap::stfa({{fault = new FpDisabled;}});
                    0x35: Trap::stqfa({{fault = new FpDisabled;}});
                    0x36: Trap::stdfa({{fault = new FpDisabled;}});

                    0x3C: Cas::casa(
                            {{uint64_t val = Mem.uw;
                            if(Rs2.uw == val)
                                    Mem.uw = Rd.uw;
                            Rd.uw = val;
                    }}); //CASA
                    0x3D: Noop::prefetcha({{ }}); //PREFETCHA
                    0x3E: Cas::casxa({{
                            uint64_t val = Mem.udw;
                            if(Rs2 == val)
                                    Mem.udw = Rd;
                            Rd = val;
                    }}); //CASXA
            }
    }
}
