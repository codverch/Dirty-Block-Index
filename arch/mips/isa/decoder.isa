////////////////////////////////////////////////////////////////////
//
// The actual MIPS32 ISA decoder
// -----------------------------
// The following instructions are specified in the MIPS32 ISA
// Specification. Decoding closely follows the style specified
// in the MIPS32 ISAthe specification document starting with Table
// A-2 (document available @ www.mips.com)
//
//@todo: Distinguish "unknown/future" use insts from "reserved"
// ones
decode OPCODE_HI default FailUnimpl::unknown() {

    // Derived From ... Table A-2 MIPS32 ISA Manual
    0x0: decode OPCODE_LO default FailUnimpl::reserved(){

        0x0: decode FUNCTION_HI {
            0x0: decode FUNCTION_LO {
              0x1: decode MOVCI {
                format BasicOp {
                  0: movf({{ if( xc->miscRegs.fpcr == 0) Rd = Rs}});
                  1: movt({{ if( xc->miscRegs.fpcr == 1) Rd = Rs}});
                }
              }

              format BasicOp {

                //Table A-3 Note: "1. Specific encodings of the rt, rd, and sa fields
                //are used to distinguish among the SLL, NOP, SSNOP and EHB functions."

                0x0: sll({{ Rd = Rt.uw << SA; }});

                0x2: decode SRL {
                   0: srl({{ Rd = Rt.uw >> SA; }});

                   //Hardcoded assuming 32-bit ISA, probably need parameter here
                   1: rotr({{ Rd = (Rt.uw << (32 - SA)) | (Rt.uw >> SA);}});
                 }

                 0x3: sra({{ Rd = Rt.sw >> SA; }});

                 0x4: sllv({{ Rd = Rt.uw << Rs<4:0>; }});

                 0x6: decode SRLV {
                   0: srlv({{ Rd = Rt.uw >> Rs<4:0>; }});

                   //Hardcoded assuming 32-bit ISA, probably need parameter here
                   1: rotrv({{ Rd = (Rt.uw << (32 - Rs<4:0>)) | (Rt.uw >> Rs<4:0>);}});
                 }

                 0x7: srav({{ Rd = Rt.sw >> Rs<4:0>; }});
              }
            }

            0x1: decode FUNCTION_LO {

              //Table A-3 Note: "Specific encodings of the hint field are used
              //to distinguish JR from JR.HB and JALR from JALR.HB"
              format Jump {
                0x0: jr(IsReturn);
                0x1: jalr(IsCall,IsReturn);
              }

              format BasicOp {
                0x2: movz({{ if (Rt == 0) Rd = Rs; }});
                0x3: movn({{ if (Rt != 0) Rd = Rs; }});
              }

              format Trap {
                0x4: syscall({{ xc->syscall()}},IsNonSpeculative);
                0x5: break({{ }});
                0x7: sync({{ }});
              }
            }

            0x2: decode FUNCTION_LO {
              format BasicOp {
                0x0: mfhi({{ Rd = xc->miscRegs.hi; }});
                0x1: mthi({{ xc->miscRegs.hi = Rs; }});
                0x2: mflo({{ Rd = xc->miscRegs.lo; }});
                0x3: mtlo({{ xc->miscRegs.lo = Rs; }});
              }
            };

            0x3: decode FUNCTION_LO {
              format IntOp {
                0x0: mult({{
                        INT64 temp1 = Rs.sw * Rt.sw;
                        xc->miscRegs.hi->temp1<63:32>;
                        xc->miscRegs.lo->temp1<31:0>
                }});

                0x1: multu({{
                        INT64 temp1 = Rs.uw * Rt.uw;
                        xc->miscRegs.hi->temp1<63:32>;
                        xc->miscRegs.lo->temp1<31:0>
                        Rd.sw = Rs.uw * Rt.uw;
                }});

                0x2: div({{
                        xc->miscRegs.hi = Rs.sw % Rt.sw;
                        xc->miscRegs.lo = Rs.sw / Rt.sw;
                        }});

                0x3: divu({{
                        xc->miscRegs.hi = Rs.uw % Rt.uw;
                        xc->miscRegs.lo = Rs.uw / Rt.uw;
                        }});
              }
            };

            0x4: decode FUNCTION_LO {
              format IntOp {
                0x0: add({{  Rd.sw = Rs.sw + Rt.sw;}});
                0x1: addu({{ Rd.uw = Rs.uw + Rt.uw;}});
                0x2: sub({{ Rd.sw = Rs.sw - Rt.sw;}});
                0x3: subu({{ Rd.uw = Rs.uw - Rt.uw;}});
                0x4: and({{ Rd.sw = Rs.uw & Rt.uw;}});
                0x5: or({{ Rd.sw = Rs.uw | Rt.uw;}});
                0x6: xor({{ Rd.sw = Rs.uw ^ Rt.uw;}});
                0x7: nor({{ Rd.sw = ~(Rs.uw | Rt.uw);}});
              }
            }

            0x5: decode FUNCTION_LO {
              format IntOp{
                0x2: slt({{  Rd.sw = ( Rs.sw < Rt.sw ) ? 1 : 0}});
                0x3: sltu({{ Rd.uw = ( Rs.uw < Rt.uw ) ? 1 : 0}});
              }
            };

            0x6: decode FUNCTION_LO {
              format Trap {
                 0x0: tge({{ }});
                 0x1: tgeu({{ }});
                 0x2: tlt({{ }});
                 0x3: tltu({{ }});
                 0x4: teq({{ }});
                 0x6: tne({{ }});
              }
            }
        }

        0x1: decode REGIMM_HI {
            0x0: decode REGIMM_LO {
              format Branch {
                0x0: bltz({{ cond = (Rs.sq < 0); }});
                0x1: bgez({{ cond = (Rs.sq >= 0); }});

                //MIPS obsolete instructions
                0x2: bltzl({{ cond = (Rs.sq < 0); }});
                0x3: bgezl({{ cond = (Rs.sq >= 0); }});
              }
            }

            0x1: decode REGIMM_LO {
              format Trap {
                 0x0: tgei({{ }});
                 0x1: tgeiu({{ }});
                 0x2: tlti({{ }});
                 0x3: tltiu({{ }});
                 0x4: teqi({{ }});
                 0x6: tnei({{ }});
              }
            }

            0x2: decode REGIMM_LO {
              format Branch {
                0x0: bltzal({{ cond = (Rs.sq < 0); }});
                0x1: bgezal({{ cond = (Rs.sq >= 0); }});

                //MIPS obsolete instructions
                0x2: bltzall({{ cond = (Rs.sq < 0); }});
                0x3: bgezall({{ cond = (Rs.sq >= 0); }});
              }
            }

            0x3: decode REGIMM_LO {
              format Trap {
                0x7: synci({{ }});
              }
            }
        }

        format Jump {
            0x2: j();
            0x3: jal(IsCall);
        }

        format Branch {
            0x4: beq({{ cond = (Rs.sq == 0); }});
            0x5: bne({{ cond = (Rs.sq !=  0); }});
            0x6: blez({{ cond = (Rs.sq <= 0); }});
            0x7: bgtz({{ cond = (Rs.sq > 0); }});
        }
    };

    0x1: decode OPCODE_LO default FailUnimpl::reserved(){
        format IntOp {
            0x0: addi({{ Rt.sw = Rs.sw + INTIMM; }});
            0x1: addiu({{ Rt.uw = Rs.uw + INTIMM;}});
            0x2: slti({{ Rt.sw = ( Rs.sw < INTIMM ) ? 1 : 0 }});
            0x3: sltiu({{ Rt.uw = ( Rs.uw < INTIMM ) ? 1 : 0 }});
            0x4: andi({{ Rt.sw = Rs.sw & INTIMM;}});
            0x5: ori({{ Rt.sw = Rs.sw | INTIMM;}});
            0x6: xori({{ Rt.sw = Rs.sw ^ INTIMM;}});
            0x7: lui({{ Rt = INTIMM << 16}});
        };
    };

    0x2: decode OPCODE_LO default FailUnimpl::reserved(){

      //Table A-11 MIPS32 COP0 Encoding of rs Field
      0x0: decode RS_MSB {
        0x0: decode RS {

           format BasicOp {
                0x0: mfc0({{ }});
                0xC: mtc0({{ }});
                0xA: rdpgpr({{ }});
            }

          0xB: decode SC {
            format BasicOp {
                0x0: di({{ Rt.sw = xc->miscRegs.statusReg; statusReg[IE] = 0;}});
                0x1: ei({{ Rt.sw = xc->miscRegs.statusReg; statusReg[IE] = 1;}});
            }
          }

          0xE: BasicOp::wrpgpr({{ }});
        }

        //Table A-12 MIPS32 COP0 Encoding of Function Field When rs=CO
        0x1: decode FUNCTION {
          format Trap {
                0x01: tlbr({{ }});
                0x02: tlbwi({{ }});
                0x06: tlbwr({{ }});
                0x08: tlbp({{ }});
          }

          format WarnUnimpl {
                0x18: eret({{ }});
                0x1F: deret({{ }});
                0x20: wait({{ }});
          }
        }
      }

      //Table A-13 MIPS32 COP1 Encoding of rs Field
      0x1: decode RS_MSB {

        0x0: decode RS_HI {
          0x0: decode RS_LO {
            format FloatOp {
              0x0: mfc1({{ }});
              0x2: cfc1({{ }});
              0x3: mfhc1({{ }});
              0x4: mtc1({{ }});
              0x6: ctc1({{ }});
              0x7: mftc1({{ }});
            }
          }

          0x1: decode ND {
            0x0: decode TF {
              format Branch {
                0x0: bc1f({{ cond = (xc->miscRegs.fpcr == 0); }});
                0x1: bc1t({{ cond = (xc->miscRegs.fpcr == 1); }});
              }
            }

            0x1: decode TF {
              format Branch {
                0x0: bc1fl({{ cond = (xc->miscRegs.fpcr == 0); }});
                0x1: bc1tl({{ cond = (xc->miscRegs.fpcr == 1); }});
              }
            }
          }
        }

        0x1: decode RS_HI {
          0x2: decode RS_LO {

            //Table A-14 MIPS32 COP1 Encoding of Function Field When rs=S
            //(( single-word ))
            0x0: decode RS_HI {
              0x0: decode RS_LO {
                format FloatOp {
                  0x0: add_fmt({{ }});
                  0x1: sub_fmt({{ }});
                  0x2: mul_fmt({{ }});
                  0x3: div_fmt({{ }});
                  0x4: sqrt_fmt({{ }});
                  0x5: abs_fmt({{ }});
                  0x6: mov_fmt({{ }});
                  0x7: neg_fmt({{ }});
                }
              }

              0x1: decode RS_LO {
                //only legal for 64 bit
                format Float64Op {
                  0x0: round_l({{ }});
                  0x1: trunc_l({{ }});
                  0x2: ceil_l({{ }});
                  0x3: floor_l({{ }});
                }

                format FloatOp {
                  0x4: round_w({{ }});
                  0x5: trunc_w({{ }});
                  0x6: ceil_w({{ }});
                  0x7: floor_w({{ }});
                }
              }

              0x2: decode RS_LO {
                0x1: decode MOVCF {
                  format FloatOp {
                    0x0: movf_fmt({{ }});
                    0x1: movt_fmt({{ }});
                  }
                }

                format BasicOp {
                  0x2: movz({{ if (Rt == 0) Rd = Rs; }});
                  0x3: movn({{ if (Rt != 0) Rd = Rs; }});
                }

                format Float64Op {
                  0x2: recip({{ }});
                  0x3: rsqrt{{ }});
                }
              }

              0x4: decode RS_LO {
                0x1: cvt_d({{ }});
                0x4: cvt_w({{ }});

                //only legal for 64 bit
                format Float64Op {
                  0x5: cvt_l({{ }});
                  0x6: cvt_ps({{ }});
                }
              }
            }

            //Table A-15 MIPS32 COP1 Encoding of Function Field When rs=D
            0x1: decode RS_HI {
              0x0: decode RS_LO {
                format FloatOp {
                  0x0: add_fmt({{ }});
                  0x1: sub_fmt({{ }});
                  0x2: mul_fmt({{ }});
                  0x3: div_fmt({{ }});
                  0x4: sqrt_fmt({{ }});
                  0x5: abs_fmt({{ }});
                  0x6: mov_fmt({{ }});
                  0x7: neg_fmt({{ }});
                }
              }

              0x1: decode RS_LO {
                //only legal for 64 bit
                format FloatOp64 {
                  0x0: round_l({{ }});
                  0x1: trunc_l({{ }});
                  0x2: ceil_l({{ }});
                  0x3: floor_l({{ }});
                }

                format FloatOp {
                  0x4: round_w({{ }});
                  0x5: trunc_w({{ }});
                  0x6: ceil_w({{ }});
                  0x7: floor_w({{ }});
                }
              }

              0x2: decode RS_LO {
                0x1: decode MOVCF {
                  format FloatOp {
                    0x0: movf_fmt({{ }});
                    0x1: movt_fmt({{ }});
                  }
                }

                format BasicOp {
                  0x2: movz({{ if (Rt == 0) Rd = Rs; }});
                  0x3: movn({{ if (Rt != 0) Rd = Rs; }});
                }

                format FloatOp64 {
                  0x5: recip({{ }});
                  0x6: rsqrt{{ }});
                }
              }

              0x4: decode RS_LO {
                format FloatOp {
                  0x0: cvt_s({{ }});
                  0x4: cvt_w({{ }});
                }

                //only legal for 64 bit
                format FloatOp64 {
                  0x5: cvt_l({{ }});
                }
              }
            }

            //Table A-16 MIPS32 COP1 Encoding of Function Field When rs=W
            0x4: decode FUNCTION {
              format FloatOp {
                0x10: cvt_s({{ }});
                0x10: cvt_d({{ }});
              }
            }

            //Table A-16 MIPS32 COP1 Encoding of Function Field When rs=L1
            //Note: "1. Format type L is legal only if 64-bit floating point operations
            //are enabled."
            0x5: decode FUNCTION_HI {
              format FloatOp {
                0x10: cvt_s({{ }});
                0x11: cvt_d({{ }});
              }
            }

            //Table A-17 MIPS64 COP1 Encoding of Function Field When rs=PS1
            //Note: "1. Format type PS is legal only if 64-bit floating point operations
            //are enabled. "
            0x6: decode RS_HI {
              0x0: decode RS_LO {
                format FloatOp64 {
                  0x0: add_fmt({{ }});
                  0x1: sub_fmt({{ }});
                  0x2: mul_fmt({{ }});
                  0x5: abs_fmt({{ }});
                  0x6: mov_fmt({{ }});
                  0x7: neg_fmt({{ }});
                }
              }

              0x2: decode RS_LO {
                0x1: decode MOVCF {
                  format FloatOp64 {
                    0x0: movf_fmt({{ }});
                    0x1: movt_fmt({{ }});
                  }
                }

              }

              0x4: decode RS_LO {
                0x0: FloatOp64::cvt_s_pu({{ }});
              }

              0x5: decode RS_LO {
                format FloatOp64 {
                  0x0: cvt_s_pl({{ }});
                  0x4: pll_s_pl({{ }});
                  0x5: plu_s_pl({{ }});
                  0x6: pul_s_pl({{ }});
                  0x7: puu_s_pl({{ }});
                }
              }
            }
      }

      //Table A-19 MIPS32 COP2 Encoding of rs Field
      0x2: decode RS_MSB {
        0x0: decode RS_HI {
          0x0: decode RS_LO {
            format WarnUnimpl {
                0x0: mfc2({{ }});
                0x2: cfc2({{ }});
                0x3: mfhc2({{ }});
                0x4: mtc2({{ }});
                0x6: ctc2({{ }});
                0x7: mftc2({{ }});
            }
          }

          0x1: decode ND {
            0x0: decode TF {
              format Branch {
                0x0: bc2f({{ cond = (xc->miscRegs.cop2cc == 0); }}, COP2);
                0x1: bc2t({{ cond = (xc->miscRegs.cop2cc == 1); }}, COP2}});
              }
            }

            0x1: decode TF {
              format Branch {
                0x0: bc2fl({{ cond = (xc->miscRegs.cop2cc == 0); }}, COP2}});
                0x1: bc2tl({{ cond = (xc->miscRegs.cop2cc == 1); }}, COP2}});
              }
            }
          }
        }
      }

      //Table A-20 MIPS64 COP1X Encoding of Function Field 1
      //Note: "COP1X instructions are legal only if 64-bit floating point
      //operations are enabled."
      0x3: decode FUNCTION_HI {
        0x0: decode FUNCTION_LO {
                format Memory {
                  0x0: lwxc1({{ }});
                  0x1: ldxc1({{ }});
                  0x5: luxc1({{ }});
                }
        }

        0x1: decode FUNCTION_LO {
                format Memory {
                  0x0: swxc1({{ }});
                  0x1: sdxc1({{ }});
                  0x5: suxc1({{ }});
                  0x7: prefx({{ }});
                }
        }

        format FloatOp {
                0x3: alnv_ps({{ }});

                0x4: decode FUNCTION_LO {
                  0x0: madd_s({{ }});
                  0x1: madd_d({{ }});
                  0x6: madd_ps({{ }});
                }

                0x5: decode FUNCTION_LO {
                  0x0: msub_s({{ }});
                  0x1: msub_d({{ }});
                  0x6: msub_ps({{ }});
                }

                0x6: decode FUNCTION_LO {
                  0x0: nmadd_s({{ }});
                  0x1: nmadd_d({{ }});
                  0x6: nmadd_ps({{ }});
                }

                0x7: decode FUNCTION_LO {
                  0x0: nmsub_s({{ }});
                  0x1: nmsub_d({{ }});
                  0x6: nmsub_ps({{ }});
                }
        }
      }

      //MIPS obsolete instructions
        format Branch {
              0x4: beql({{ cond = (Rs.sq == 0); }});
              0x5: bnel({{ cond = (Rs.sq != 0); }});
              0x6: blezl({{ cond = (Rs.sq <= 0); }});
              0x7: bgtzl({{ cond = (Rs.sq > 0); }});
        }
    };

    0x3: decode OPCODE_LO default FailUnimpl::reserved() {

        //Table A-5 MIPS32 SPECIAL2 Encoding of Function Field
        0x4: decode FUNCTION_HI {

            0x0: decode FUNCTION_LO {
                format IntOp {
                   0x0: madd({{
                        INT64 temp1 = Hi.sw << 32 | Lo.sw >> 32;
                        temp1 = temp1 + (Rs.sw * Rt.sw);
                        xc->miscRegs.hi->temp1<63:32>;
                        xc->miscRegs.lo->temp1<31:0>
                        }});

                   0x1: maddu({{
                        INT64 temp1 = Hi.uw << 32 | Lo.uw >> 32;
                        temp1 = temp1 + (Rs.uw * Rt.uw);
                        xc->miscRegs.hi->temp1<63:32>;
                        xc->miscRegs.lo->temp1<31:0>
                        }});

                   0x2: mul({{ 	Rd.sw = Rs.sw * Rt.sw; 	}});

                   0x4: msub({{
                        INT64 temp1 = Hi.sw << 32 | Lo.sw >> 32;
                        temp1 = temp1 - (Rs.sw * Rt.sw);
                        xc->miscRegs.hi->temp1<63:32>;
                        xc->miscRegs.lo->temp1<31:0>
                        }});

                   0x5: msubu({{
                        INT64 temp1 = Hi.uw << 32 | Lo.uw >> 32;
                        temp1 = temp1 - (Rs.uw * Rt.uw);
                        xc->miscRegs.hi->temp1<63:32>;
                        xc->miscRegs.lo->temp1<31:0>
                        }});
                }
            }

            0x4: decode FUNCTION_LO {
                  format BasicOp {
                      0x0: clz({{
                        int cnt = 0;
                        int idx = 0;
                        while ( Rs.uw<idx>!= 1) {
                                cnt++;
                                idx--;
                        }

                        Rd.uw = cnt;
                        }});

                      0x1: clo({{
                        int cnt = 0;
                        int idx = 0;
                        while ( Rs.uw<idx>!= 0) {
                                cnt++;
                                idx--;
                        }

                        Rd.uw = cnt;
                        }});
                  }
            }

            0x7: decode FUNCTION_LO {
              0x7: WarnUnimpl::sdbbp({{ }});
            }
        }

        //Table A-6 MIPS32 SPECIAL3 Encoding of Function Field for Release 2 of the Architecture
        0x7: decode FUNCTION_HI {

          0x0: decode FUNCTION_LO {
                format WarnUnimpl {
                    0x1: ext({{ }});
                    0x4: ins({{ }});
                }
          }

          //Table A-10 MIPS32 BSHFL Encoding of sa Field
          0x4: decode SA {
                format BasicOp {
                    0x02: wsbh({{ }});
                    0x10: seb({{ Rd.sw = /* sext32(Rt<7>,24)  | */ Rt<7:0>}});
                    0x18: seh({{ Rd.sw = /* sext32(Rt<15>,16) | */ Rt<15:0>}});
                }
          }

          0x6: decode FUNCTION_LO {
            0x7: BasicOp::rdhwr({{ }});
          }
        }
    };

    0x4: decode OPCODE_LO default FailUnimpl::reserved() {
        format Memory {
            0x0: lb({{ EA = Rs + disp; }}, {{ Rb.sw = Mem.sb; }});
            0x1: lh({{ EA = Rs + disp; }}, {{ Rb.sw = Mem.sh; }});
            0x2: lwl({{ EA = Rs + disp; }}, {{ Rb.sw = Mem.sw; }}, WordAlign);
            0x3: lw({{ EA = Rs + disp; }}, {{ Rb.uq = Mem.sb; }});
            0x4: lbu({{ EA = Rs + disp; }}, {{ Rb.uw = Mem.ub; }});
            0x5: lhu({{ EA = Rs + disp; }}, {{ Rb.uw = Mem.uh; }});
            0x6: lwr({{ EA = Rs + disp; }}, {{ Rb.uw = Mem.uw; }}, WordAlign);
        };

        0x7: FailUnimpl::reserved({{ }});
    };

    0x5: decode OPCODE_LO default FailUnimpl::reserved() {
        format Memory {
            0x0: sb({{ EA = Rs + disp; }}, {{ Mem.ub = Rt<7:0>; }});
            0x1: sh({{ EA = Rs + disp; }},{{ Mem.uh = Rt<15:0>; }});
            0x2: swl({{ EA = Rs + disp; }},{{ Mem.ub = Rt<31:0>; }},WordAlign);
            0x3: sw({{ EA = Rs + disp; }},{{ Mem.ub = Rt<31:0>; }});
            0x6: swr({{ EA = Rs + disp; }},{{ Mem.ub = Rt<31:0>; }},WordAlign);
        };

        format WarnUnimpl {
            0x4: reserved({{ }});
            0x5: reserved({{ }});
            0x7: cache({{ }});
        };

    };

    0x6: decode OPCODE_LO default FailUnimpl::reserved() {
        format Memory {
            0x0: ll({{ }});
            0x1: lwc1({{ EA = Rs + disp; }},{{ Ft<31:0> = Mem.uf; }});
            0x5: ldc1({{ EA = Rs + disp; }},{{ Ft<63:0> = Mem.df; }});
        };
    };

    0x7: decode OPCODE_LO default FailUnimpl::reserved() {
        format Memory {
            0x0: sc({{ }});
            0x1: swc1({{ EA = Rs + disp; }},{{ Mem.uf = Ft<31:0>; }});
            0x5: sdc1({{ EA = Rs + disp; }},{{ Mem.df = Ft<63:0>; }});
        };

    }
}


